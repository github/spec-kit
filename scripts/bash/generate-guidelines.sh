#!/usr/bin/env bash

#
# generate-guidelines.sh - Corporate guideline generation from documents and reference projects
#
# Usage:
#   ./generate-guidelines.sh [SOURCES_PATH]
#
# This script enumerates corporate documents and reference projects for AI analysis.
# The AI agent will extract principles and generate/update coding guidelines.
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
SOURCES_PATH=""

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Output directory (fixed location)
OUTPUT_DIR="$REPO_ROOT/.guidelines-analysis"

# Functions

print_header() {
    echo -e "${BLUE}======================================${NC}"
    echo -e "${BLUE}$1${NC}"
    echo -e "${BLUE}======================================${NC}"
}

print_success() {
    echo -e "${GREEN}âœ“ $1${NC}"
}

print_error() {
    echo -e "${RED}âœ— $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš  $1${NC}"
}

print_info() {
    echo -e "${BLUE}â„¹ $1${NC}"
}

usage() {
    cat <<EOF
Usage: $0 [SOURCES_PATH]

Generate or update corporate coding guidelines from documents and reference projects.

Arguments:
  SOURCES_PATH         Path to folder containing docs/ and reference-projects/ subdirectories

Expected structure:
  SOURCES_PATH/
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ security-guidelines.pdf
    â”‚   â”œâ”€â”€ coding-standards.md
    â”‚   â””â”€â”€ ...
    â””â”€â”€ reference-projects/
        â”œâ”€â”€ project-a/
        â”œâ”€â”€ project-b/
        â””â”€â”€ ...

Examples:
  # Generate guidelines from temp folder
  $0 /tmp/my-standards

  # Generate guidelines from current directory
  $0 .

Workflow:
  1. Enumerate all documents in docs/ subdirectory
  2. Enumerate all reference projects in reference-projects/ subdirectory
  3. Generate file manifests (JSON)
  4. Create analysis workspace (.guidelines-analysis/)
  5. AI agent analyzes:
     - Documents: Extract explicit principles
     - Code: Reverse-engineer implicit patterns
     - Synthesize: Merge findings into guidelines

Output:
  The script prepares an analysis workspace for AI with:
  - documents-manifest.json      List of corporate documents
  - projects-manifest.json       List of reference projects
  - {project-name}-files.json    File inventory per project
  - (Guidelines generated by AI in .guidelines/ directory)

Options:
  -h, --help           Show this help message

EOF
    exit 0
}

check_dependencies() {
    print_header "Checking Dependencies"

    local missing=0

    # Check jq (required for JSON generation)
    if ! command -v jq &> /dev/null; then
        print_error "jq is required but not installed"
        print_info "Why? It prevents JSON injection vulnerabilities"
        print_info "Install: sudo apt-get install jq  OR  brew install jq"
        print_info "Corporate? Download portable binary: https://github.com/jqlang/jq/releases"
        print_info "Alternative: Use PowerShell version (scripts/powershell/generate-guidelines.ps1)"
        missing=1
    else
        print_success "jq found: $(jq --version)"
    fi

    if [[ $missing -eq 1 ]]; then
        exit 1
    fi

    echo ""
}

validate_sources_path() {
    print_header "Validating Sources Path"

    if [ ! -d "$SOURCES_PATH" ]; then
        print_error "Sources path does not exist: $SOURCES_PATH"
        exit 1
    fi

    SOURCES_PATH="$(cd "$SOURCES_PATH" && pwd)"
    print_success "Sources path: $SOURCES_PATH"

    echo ""
}

check_structure() {
    print_header "Checking Directory Structure"

    local has_docs=0
    local has_projects=0

    # Check for docs/ subdirectory
    if [ -d "$SOURCES_PATH/docs" ]; then
        has_docs=1
        print_success "Found docs/ subdirectory"
    else
        print_warning "docs/ subdirectory not found"
        print_info "Looking for documents in root..."
    fi

    # Check for reference-projects/ subdirectory
    if [ -d "$SOURCES_PATH/reference-projects" ]; then
        has_projects=1
        print_success "Found reference-projects/ subdirectory"
    else
        print_warning "reference-projects/ subdirectory not found"
        print_info "Looking for projects in root..."
    fi

    echo ""

    # Return status for AI to handle
    if [[ $has_docs -eq 0 ]] && [[ $has_projects -eq 0 ]]; then
        print_warning "Expected structure not found, but continuing..."
        print_info "AI will attempt to categorize files automatically"
        echo ""
    fi
}

setup_output_directory() {
    print_header "Setting Up Analysis Workspace"

    mkdir -p "$OUTPUT_DIR"
    print_success "Output directory: $OUTPUT_DIR"

    echo ""
}

enumerate_documents() {
    print_header "Enumerating Corporate Documents"

    local docs_dir
    local doc_count=0

    # Determine docs directory
    if [ -d "$SOURCES_PATH/docs" ]; then
        docs_dir="$SOURCES_PATH/docs"
    else
        docs_dir="$SOURCES_PATH"
    fi

    # Create documents manifest
    local manifest_file="$OUTPUT_DIR/documents-manifest.json"

    print_info "Scanning for documents (*.pdf, *.md, *.docx, *.txt)..."

    # Find all document files
    local doc_files=()
    while IFS= read -r -d '' file; do
        doc_files+=("$file")
        ((doc_count++))
    done < <(find "$docs_dir" -type f \( -iname "*.pdf" -o -iname "*.md" -o -iname "*.docx" -o -iname "*.txt" -o -iname "*.doc" \) -print0 2>/dev/null || true)

    # Generate JSON manifest
    if [ ${#doc_files[@]} -eq 0 ]; then
        print_warning "No documents found in $docs_dir"
        echo '{"documents": [], "count": 0, "base_path": "'"$docs_dir"'"}' > "$manifest_file"
    else
        {
            echo '{'
            echo '  "documents": ['

            local first=1
            for doc in "${doc_files[@]}"; do
                if [ $first -eq 0 ]; then
                    echo ','
                fi
                first=0

                local filename=$(basename "$doc")
                local rel_path="${doc#$docs_dir/}"
                local size=$(stat -f%z "$doc" 2>/dev/null || stat -c%s "$doc" 2>/dev/null || echo "0")

                # Use jq to safely escape strings
                local json_entry=$(jq -n \
                    --arg path "$doc" \
                    --arg rel "$rel_path" \
                    --arg name "$filename" \
                    --arg sz "$size" \
                    '{path: $path, relative_path: $rel, filename: $name, size_bytes: ($sz | tonumber)}')

                echo -n "    $json_entry"
            done

            echo ''
            echo '  ],'
            echo '  "count": '"$doc_count"','
            echo '  "base_path": "'"$docs_dir"'"'
            echo '}'
        } > "$manifest_file"

        print_success "Found $doc_count documents"
        print_success "Manifest: $manifest_file"
    fi

    echo ""
}

enumerate_projects() {
    print_header "Enumerating Reference Projects"

    local projects_dir
    local project_count=0

    # Determine projects directory
    if [ -d "$SOURCES_PATH/reference-projects" ]; then
        projects_dir="$SOURCES_PATH/reference-projects"
    else
        projects_dir="$SOURCES_PATH"
    fi

    # Create projects manifest
    local manifest_file="$OUTPUT_DIR/projects-manifest.json"

    print_info "Scanning for reference projects..."

    # Find all subdirectories (treating each as a potential project)
    local project_dirs=()
    while IFS= read -r -d '' dir; do
        # Skip hidden directories and common non-project dirs
        local dirname=$(basename "$dir")
        if [[ ! "$dirname" =~ ^\. ]] && [[ "$dirname" != "docs" ]] && [[ "$dirname" != "node_modules" ]]; then
            project_dirs+=("$dir")
            ((project_count++))
        fi
    done < <(find "$projects_dir" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null || true)

    # Generate JSON manifest
    if [ ${#project_dirs[@]} -eq 0 ]; then
        print_warning "No reference projects found in $projects_dir"
        echo '{"projects": [], "count": 0, "base_path": "'"$projects_dir"'"}' > "$manifest_file"
    else
        {
            echo '{'
            echo '  "projects": ['

            local first=1
            for proj in "${project_dirs[@]}"; do
                if [ $first -eq 0 ]; then
                    echo ','
                fi
                first=0

                local project_name=$(basename "$proj")
                local rel_path="${proj#$projects_dir/}"

                # Count files in project
                local file_count=$(find "$proj" -type f 2>/dev/null | wc -l | tr -d ' ')

                # Use jq to safely escape strings
                local json_entry=$(jq -n \
                    --arg path "$proj" \
                    --arg rel "$rel_path" \
                    --arg name "$project_name" \
                    --arg cnt "$file_count" \
                    '{path: $path, relative_path: $rel, name: $name, file_count: ($cnt | tonumber)}')

                echo -n "    $json_entry"

                # Generate file list for this project
                print_info "  Enumerating files in $project_name..."
                enumerate_project_files "$proj" "$project_name"
            done

            echo ''
            echo '  ],'
            echo '  "count": '"$project_count"','
            echo '  "base_path": "'"$projects_dir"'"'
            echo '}'
        } > "$manifest_file"

        print_success "Found $project_count reference projects"
        print_success "Manifest: $manifest_file"
    fi

    echo ""
}

enumerate_project_files() {
    local project_path="$1"
    local project_name="$2"

    local files_manifest="$OUTPUT_DIR/${project_name}-files.json"

    # Find all files in project (excluding common build artifacts and dependencies)
    local file_list=()
    local file_count=0

    while IFS= read -r -d '' file; do
        # Skip binary files and large files (>10MB)
        local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
        if [ "$size" -gt 10485760 ]; then
            continue
        fi

        file_list+=("$file")
        ((file_count++))
    done < <(find "$project_path" -type f \
        ! -path "*/node_modules/*" \
        ! -path "*/bin/*" \
        ! -path "*/obj/*" \
        ! -path "*/target/*" \
        ! -path "*/build/*" \
        ! -path "*/dist/*" \
        ! -path "*/.git/*" \
        ! -path "*/__pycache__/*" \
        ! -path "*/venv/*" \
        ! -path "*/.venv/*" \
        -print0 2>/dev/null || true)

    # Generate JSON manifest
    {
        echo '{'
        echo '  "project_name": "'"$project_name"'",'
        echo '  "project_path": "'"$project_path"'",'
        echo '  "files": ['

        local first=1
        for file in "${file_list[@]}"; do
            if [ $first -eq 0 ]; then
                echo ','
            fi
            first=0

            local filename=$(basename "$file")
            local rel_path="${file#$project_path/}"
            local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
            local ext="${filename##*.}"

            # Use jq to safely escape strings
            local json_entry=$(jq -n \
                --arg path "$file" \
                --arg rel "$rel_path" \
                --arg name "$filename" \
                --arg sz "$size" \
                --arg extension "$ext" \
                '{path: $path, relative_path: $rel, filename: $name, size_bytes: ($sz | tonumber), extension: $extension}')

            echo -n "    $json_entry"
        done

        echo ''
        echo '  ],'
        echo '  "file_count": '"$file_count"
        echo '}'
    } > "$files_manifest"

    print_success "    Enumerated $file_count files -> ${project_name}-files.json"
}

show_summary() {
    print_header "Analysis Workspace Ready"

    print_success "Workspace created successfully!"
    echo ""
    print_info "Workspace location: $OUTPUT_DIR"
    print_info "Documents manifest: $OUTPUT_DIR/documents-manifest.json"
    print_info "Projects manifest: $OUTPUT_DIR/projects-manifest.json"
    echo ""

    # Count documents
    local doc_count=0
    if [ -f "$OUTPUT_DIR/documents-manifest.json" ]; then
        doc_count=$(jq -r '.count' "$OUTPUT_DIR/documents-manifest.json" 2>/dev/null || echo "0")
    fi

    # Count projects
    local proj_count=0
    if [ -f "$OUTPUT_DIR/projects-manifest.json" ]; then
        proj_count=$(jq -r '.count' "$OUTPUT_DIR/projects-manifest.json" 2>/dev/null || echo "0")
    fi

    print_info "Summary:"
    print_info "  - Corporate documents: $doc_count"
    print_info "  - Reference projects: $proj_count"
    echo ""

    if [ "$doc_count" -eq 0 ] && [ "$proj_count" -eq 0 ]; then
        print_error "No documents or projects found!"
        print_info "Expected structure:"
        print_info "  $SOURCES_PATH/docs/           (corporate documents)"
        print_info "  $SOURCES_PATH/reference-projects/  (reference codebases)"
        exit 1
    fi

    if [ "$doc_count" -eq 0 ]; then
        print_warning "No corporate documents found"
        print_info "Guidelines will be generated from reference projects only"
    fi

    if [ "$proj_count" -eq 0 ]; then
        print_warning "No reference projects found"
        print_info "Guidelines will be generated from documents only"
    fi

    echo ""
    print_info "Next steps:"
    print_info "1. AI will analyze documents to extract explicit principles"
    print_info "2. AI will analyze reference projects to identify implicit patterns"
    print_info "3. AI will synthesize findings into coding guidelines"
    print_info "4. Generated guidelines will be saved to .guidelines/ directory"
    echo ""
    print_success "ðŸ¤– Ready for AI analysis!"
}

# Main script

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                ;;
            *)
                if [ -z "$SOURCES_PATH" ]; then
                    SOURCES_PATH="$1"
                else
                    print_error "Unknown option: $1"
                    usage
                fi
                shift
                ;;
        esac
    done

    # Require sources path
    if [ -z "$SOURCES_PATH" ]; then
        print_error "SOURCES_PATH is required"
        echo ""
        usage
    fi

    # Welcome message
    print_header "Corporate Guideline Generation"
    echo ""

    # Run workflow
    check_dependencies
    validate_sources_path
    check_structure
    setup_output_directory
    enumerate_documents
    enumerate_projects
    show_summary

    exit 0
}

main "$@"
