# ggen: Ontology Compiler for Spec-Kit

**ggen compiles RDF ontologies into type-safe code.** Just as you wouldn't hand-write assembly when you have a compiler, you don't hand-write data models when you have ontologies.

This documentation follows the [Diátaxis framework](https://diataxis.fr/):
- **[Tutorial](#tutorial)**: Learn by building your first ontology-driven project
- **[How-To Guides](#how-to-guides)**: Solve specific problems
- **[Reference](#reference)**: Technical specifications and API
- **[Explanation](#explanation)**: Understanding ontology-driven development

---

## Tutorial

**Goal**: Compile your first ontology into working code in 10 minutes.

### Prerequisites

```bash
# Install Rust (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Install ggen
cargo install ggen

# Verify installation
ggen --version  # Should show: ggen 5.0.0
```

### Step 1: Create Your Domain Ontology

Create `schema/task-domain.ttl`:

```turtle
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix task: <https://example.com/task#> .

# Define a Task entity
task:Task a rdfs:Class ;
    rdfs:label "Task" ;
    rdfs:comment "A work item to be completed" .

# Task properties
task:title a rdf:Property ;
    rdfs:domain task:Task ;
    rdfs:range xsd:string ;
    rdfs:label "title" .

task:completed a rdf:Property ;
    rdfs:domain task:Task ;
    rdfs:range xsd:boolean ;
    rdfs:label "completed" .
```

### Step 2: Create a Compilation Target Template

Create `templates/ggen/python.tera`:

```python
"""Generated by ggen - DO NOT EDIT"""
from dataclasses import dataclass

{% for class in classes %}
@dataclass
class {{ class.name }}:
    """{{ class.comment }}"""
    {% for property in class.properties %}
    {{ property.name }}: {{ property.python_type }}
    {% endfor %}
{% endfor %}
```

### Step 3: Configure the Compiler

Create `ggen.toml`:

```toml
[project]
name = "my-project"
version = "1.0.0"

[generation]
ontology_dir = "schema/"
templates_dir = "templates/ggen/"
output_dir = "src/generated/"
```

### Step 4: Compile

```bash
# Compile ontology to code
ggen sync

# Check the output
cat src/generated/task-domain.py
```

**Output**:
```python
"""Generated by ggen - DO NOT EDIT"""
from dataclasses import dataclass

@dataclass
class Task:
    """A work item to be completed"""
    title: str
    completed: bool
```

### What Just Happened?

You defined your domain in RDF (the ontology), and ggen **compiled** it into Python. When your domain understanding changes, you modify the `.ttl` file and recompile - the generated code updates automatically.

**Next**: Try changing the ontology (add a `due_date` property) and run `ggen sync` again. Notice the generated code updates instantly.

---

## How-To Guides

### How to Generate Code for Multiple Languages

**Problem**: You need both a Python backend and TypeScript frontend with identical type definitions.

**Solution**: Create templates for each target language, ggen compiles to all of them from one ontology.

```bash
# Project structure
.
├── schema/domain.ttl          # Single source of truth
├── templates/ggen/
│   ├── python.tera             # Python target
│   ├── typescript.tera         # TypeScript target
│   └── rust.tera              # Rust target
└── ggen.toml
```

Run `ggen sync` once, get code for all languages. When the domain changes, update the ontology and recompile - all targets stay in perfect sync.

### How to Use SPARQL Inference

**Problem**: Your ontology has implicit relationships that should be materialized in generated code.

**Solution**: Add SPARQL CONSTRUCT queries to infer new triples before compilation.

Create `schema/inference.ttl`:

```turtle
@prefix ggen: <https://ggen.io/ns#> .
@prefix task: <https://example.com/task#> .

task:InferUrgent a ggen:ConstructQuery ;
    ggen:query """
        PREFIX task: <https://example.com/task#>
        PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

        CONSTRUCT {
            ?task task:isUrgent "true"^^xsd:boolean .
        }
        WHERE {
            ?task task:dueDate ?date .
            FILTER(?date < NOW())
            FILTER NOT EXISTS { ?task task:completed "true"^^xsd:boolean }
        }
    """ .
```

ggen executes these queries during compilation, adding inferred properties to your generated types.

### How to Preserve Manual Edits

**Problem**: You need to add custom logic to generated code without losing it on recompilation.

**Solution**: Use incremental mode with `// MANUAL` markers.

**ggen.toml**:
```toml
[generation]
incremental = true
```

**Generated code with manual additions**:
```python
@dataclass
class Task:
    # GENERATED: Do not edit
    title: str
    completed: bool

    # MANUAL: Custom validation (preserved on recompile)
    def validate(self) -> bool:
        return len(self.title) > 0
```

Run `ggen sync --mode incremental` - generated sections update, manual sections are preserved.

### How to Version Your Ontology

**Problem**: You need to evolve your domain model over time without breaking existing code.

**Solution**: Use OWL versioning and deprecation.

```turtle
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix task: <https://example.com/task#> .

# Ontology version
task: a owl:Ontology ;
    owl:versionInfo "2.0.0" .

# Deprecated property
task:status a rdf:Property ;
    owl:deprecated "true"^^xsd:boolean ;
    rdfs:comment "Use task:state instead (deprecated in v2.0)" .

# Replacement property
task:state a rdf:Property ;
    rdfs:comment "Replaces deprecated task:status" .
```

Your compiler can emit warnings for deprecated properties, giving you migration paths.

### How to Integrate with CI/CD

**Problem**: Ensure generated code is always in sync with ontology in production.

**Solution**: Add verification to your CI pipeline.

```yaml
# .github/workflows/verify-ontology.yml
name: Verify Ontology Compilation
on: [push, pull_request]

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable

      - name: Install ggen
        run: cargo install ggen

      - name: Compile ontology
        run: ggen sync --mode verify

      - name: Fail if generated code is out of sync
        run: git diff --exit-code src/generated/
```

Builds fail if someone modifies generated code by hand or if the ontology and code are out of sync.

---

## Reference

### ggen.toml Configuration

Complete configuration schema:

```toml
[project]
name = "string"              # Required: Project identifier
version = "semver"           # Required: Semantic version
description = "string"       # Optional: Project description
authors = ["string"]         # Optional: List of authors
license = "SPDX"            # Optional: License identifier

[generation]
ontology_dir = "path/"       # Default: "schema/"
templates_dir = "path/"      # Default: "templates/"
output_dir = "path/"         # Default: "src/generated/"
incremental = bool           # Default: true
overwrite = bool             # Default: false

[sync]
enabled = bool               # Default: true
on_change = "save|commit|manual"  # Default: "manual"
validate_after = bool        # Default: true
conflict_mode = "fail|warn|ignore"  # Default: "fail"

[rdf]
formats = ["turtle", "rdf-xml", "n-triples"]
default_format = "turtle"
base_uri = "URI"             # Optional: Base URI for ontology
strict_validation = bool     # Default: false

[templates]
enable_caching = bool        # Default: true
auto_reload = bool           # Default: true

[output]
formatting = "default|rustfmt|prettier|black"
line_length = int            # Default: 100
indent = int                 # Default: 2
```

### CLI Commands

#### `ggen sync`

Compile ontology to code.

**Syntax**:
```bash
ggen sync [OPTIONS]
```

**Options**:
- `--from <PATH>`: Source ontology directory (default: current directory)
- `--to <PATH>`: Target output directory (default: from ggen.toml)
- `--mode <MODE>`: Sync mode
  - `full`: Complete recompilation (default)
  - `incremental`: Preserve `// MANUAL` sections
  - `verify`: Check sync status without writing (for CI)
- `--dry-run`: Show what would be generated without writing
- `--force`: Override conflicts
- `--verbose`: Detailed compilation log

**Exit Codes**:
- `0`: Success
- `1`: Manifest validation error
- `2`: Ontology load error
- `3`: SPARQL query error
- `4`: Template rendering error
- `5`: File I/O error

**Examples**:
```bash
# Standard compilation
ggen sync

# Preview changes
ggen sync --dry-run

# CI verification
ggen sync --mode verify

# Incremental update preserving manual edits
ggen sync --mode incremental
```

### Type Mappings

How RDF types map to target language types:

| XSD Type | Python | TypeScript | Rust | Java |
|----------|--------|------------|------|------|
| `xsd:string` | `str` | `string` | `String` | `String` |
| `xsd:integer` | `int` | `number` | `i64` | `Long` |
| `xsd:boolean` | `bool` | `boolean` | `bool` | `Boolean` |
| `xsd:dateTime` | `datetime` | `Date` | `DateTime<Utc>` | `Instant` |
| `xsd:decimal` | `Decimal` | `number` | `f64` | `BigDecimal` |
| Custom Class | `ClassName` | `ClassName` | `ClassName` | `ClassName` |
| Optional | `Optional[T]` | `T \| undefined` | `Option<T>` | `Optional<T>` |

### Tera Template Variables

Available in all templates:

| Variable | Type | Description |
|----------|------|-------------|
| `ontology` | string | Ontology filename |
| `classes` | array | List of RDF classes |
| `classes[].name` | string | Class name |
| `classes[].comment` | string | rdfs:comment value |
| `classes[].properties` | array | Class properties |
| `properties[].name` | string | Property name |
| `properties[].comment` | string | Property description |
| `properties[].python_type` | string | Python type name |
| `properties[].typescript_type` | string | TypeScript type name |
| `properties[].rust_type` | string | Rust type name |
| `properties[].optional` | bool | Is property optional? |
| `enumerations` | array | List of OWL enumerations |

---

## Explanation

### Why Ontology-Driven Development?

**Traditional development had a fundamental problem: the map was not the territory.**

You write specifications in English, then translate them to code. Weeks later, the spec and code diverge. Different services implement the same concept differently. Adding a new language means rewriting everything.

**The root cause**: You had multiple sources of truth that could (and did) drift apart.

### The Ontology as Compiler Input

An ontology is not documentation - it's **executable knowledge**. It's a formal, machine-readable definition of your domain that can be compiled into code, just like C compiles to assembly.

Consider this evolution:

**Era 1: Hand-written assembly**
```asm
MOV AX, 1
ADD AX, 2
```

**Era 2: Compiled from C**
```c
int result = 1 + 2;
```

**Era 3: Compiled from Ontology**
```turtle
task:Task a rdfs:Class ;
    rdfs:comment "A work item" .
```

Each level raises the abstraction, letting you express intent more clearly while the compiler handles the translation.

### Why RDF/OWL Specifically?

**Expressiveness**: RDF isn't just "fancy JSON" - it supports:
- **Open-world reasoning**: New facts can be added without breaking existing knowledge
- **Inference**: Derive new facts from existing ones (SPARQL CONSTRUCT)
- **Semantic validation**: OWL constraints catch domain violations before runtime
- **Schema evolution**: Deprecate properties, add new ones, migrate gradually

**Interoperability**: RDF is a W3C standard. Your ontology works with:
- Triple stores (Virtuoso, Blazegraph, GraphDB)
- Reasoners (Pellet, HermiT, ELK)
- Knowledge graphs (Wikidata, DBpedia)
- Academic domain ontologies (FOAF, Dublin Core, Schema.org)

**Future-proof**: Unlike proprietary schemas, RDF has been stable for 20+ years and is the foundation of the semantic web.

### The Compilation Model

When you run `ggen sync`, this happens:

1. **Load**: Parse RDF ontology (Turtle/RDF-XML/N-Triples)
2. **Infer**: Execute SPARQL CONSTRUCT queries to materialize implicit knowledge
3. **Validate**: Check OWL constraints and cardinality restrictions
4. **Transform**: Convert RDF graph to template-friendly data structures
5. **Render**: Apply Tera templates to generate target language code
6. **Format**: Run language-specific formatters (rustfmt, prettier, black)
7. **Write**: Output to file system, preserving `// MANUAL` sections if incremental

This is deterministic - same ontology always produces identical output.

### Comparison to Other Approaches

| Approach | Single Source of Truth? | Multi-language? | Inference? | Semantic Validation? |
|----------|------------------------|-----------------|------------|---------------------|
| **Hand-coding** | ❌ No (specs drift) | ❌ Manual rewrites | ❌ Manual duplication | ❌ Runtime only |
| **OpenAPI/Swagger** | ⚠️ Per-API | ✅ Via codegen | ❌ No | ⚠️ Basic |
| **Protocol Buffers** | ⚠️ Per-service | ✅ Via protoc | ❌ No | ⚠️ Type-level only |
| **GraphQL Schema** | ⚠️ Per-API | ✅ Via codegen | ❌ No | ⚠️ Type-level only |
| **JSON Schema** | ⚠️ Per-API | ⚠️ Limited | ❌ No | ⚠️ Validation only |
| **ggen + RDF** | ✅ **One ontology** | ✅ **Any language** | ✅ **SPARQL** | ✅ **OWL constraints** |

### The 2030 Perspective

By 2030, hand-coding data models will seem as archaic as:
- Writing HTML for every page (instead of component templates)
- Manual memory management (instead of garbage collection)
- Writing assembly (instead of compiling from high-level languages)

Future developers will look at legacy codebases and ask: *"Wait, you manually maintained separate type definitions for Python, TypeScript, AND Java? And they got out of sync? Why didn't you just compile from an ontology?"*

**The answer**: We do now.

### When NOT to Use Ontology-Driven Development

Ontology compilation adds value when you have:
- ✅ Complex domain models shared across services
- ✅ Multiple target languages/platforms
- ✅ Need for semantic validation and inference
- ✅ Long-lived systems that evolve over time

It may be overkill for:
- ❌ Simple CRUD apps with 3-5 tables
- ❌ Single-language, single-service projects
- ❌ Prototypes you'll throw away in a week

But if you're building systems of record that will live for years and need to integrate with other systems - ontology-driven development is the only sustainable approach.

---

## Resources

- **ggen Project**: https://github.com/seanchatmangpt/ggen
- **Crates.io**: https://crates.io/crates/ggen
- **RDF Primer**: https://www.w3.org/TR/rdf11-primer/
- **OWL 2 Primer**: https://www.w3.org/TR/owl2-primer/
- **SPARQL Tutorial**: https://www.w3.org/TR/sparql11-query/
- **Tera Templates**: https://keats.github.io/tera/
- **Diátaxis Framework**: https://diataxis.fr/

---

*This documentation is organized using the [Diátaxis](https://diataxis.fr/) framework: Tutorial (learning), How-to (problem-solving), Reference (information), Explanation (understanding).*
