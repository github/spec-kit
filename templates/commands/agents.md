---
description: Generate specialized subagents for the SpecKit workflow, referencing project skills
---

# Generate SpecKit Agents

You will create specialized subagent files in `.claude/agents/speckit/`, each designed for the **Spec-Driven Development (SDD)** workflow. Agents leverage **skills** (generated by `/setup-hooks`) for domain expertise while focusing on **workflow orchestration**.

## Key Principle: Agents Use Skills

Subagents reference skills via the `skills:` frontmatter field. Skills provide domain expertise; agents handle workflow:

```yaml
---
name: backend-coder
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet
skills: scala-standards, zio-patterns  # Auto-loaded from .claude/skills/
---
```

## Agent Types to Create

### SpecKit Workflow Agents (Primary)

1. **spec-analyzer** - Analyzes specifications and requirements
2. **designer** - Creates technical designs from specs
3. **frontend-designer** - Creates UI/UX designs with distinctive aesthetics
4. **implementer** - Implements code from designs
5. **tester** - Writes and runs tests

### Coder Specialists (Secondary)

6. **backend-coder** - Backend implementation specialist
7. **frontend-coder** - Frontend implementation specialist
8. **researcher** - Codebase exploration and pattern analysis specialist
9. **planner** - Task decomposition and workflow specialist

## Discovery Process

**IMPORTANT**: Do NOT assume any file or directory structure. Discover the project organization first.

### Step 1: Search for Documentation

Try multiple strategies to find project documentation:

```bash
# Look for documentation files (may not exist)
glob "**/*README.md"
glob "**/*CLAUDE.md"
glob "**/docs/**/*.md"
glob "**/.claude/**/*.md"
glob "**/CONTRIBUTING.md"
glob "**/ARCHITECTURE.md"

# Look for coding guidelines
glob "**/STYLE_GUIDE.md"
glob "**/.editorconfig"
glob "**/.prettierrc*"
glob "**/.eslintrc*"
```

**If documentation found**: Extract tech stack, patterns, and best practices from it.

**If no documentation found**: Proceed to code analysis (Step 2).

### Step 2: Discover Project Structure

Analyze the actual codebase structure:

```bash
# Find project root indicators
glob "**/package.json"      # Node.js
glob "**/pom.xml"           # Java/Maven
glob "**/build.gradle*"     # Java/Gradle
glob "**/Cargo.toml"        # Rust
glob "**/go.mod"            # Go
glob "**/requirements.txt"  # Python
glob "**/Gemfile"           # Ruby
glob "**/build.sbt"         # Scala
glob "**/composer.json"     # PHP

# Identify source directories
glob "**/src/**"
glob "**/lib/**"
glob "**/app/**"
glob "**/backend/**"
glob "**/frontend/**"
glob "**/server/**"
glob "**/client/**"

# Find test directories
glob "**/*test*/**"
glob "**/*spec*/**"
```

### Step 3: Identify Technologies

Extract from build/config files:

```bash
# Read package manager files (if found)
# Look for dependencies, frameworks, language versions
read package.json          # if Node.js
read build.sbt             # if Scala
read requirements.txt      # if Python
read go.mod               # if Go
read Cargo.toml           # if Rust

# Check configuration files
read tsconfig.json        # TypeScript config
read .babelrc             # Babel config
read vite.config.*        # Vite config
read webpack.config.*     # Webpack config
```

### Step 4: Analyze Code Patterns

If documentation is sparse, analyze code directly:

```bash
# Backend patterns
grep -r "class\|interface\|type\|struct" --include="*.ts" --include="*.js" --include="*.go" --include="*.rs" --include="*.scala" | head -50

# Frontend patterns
grep -r "export.*function\|export.*const.*=\|export default" --include="*.tsx" --include="*.jsx" | head -50

# Database patterns
grep -r "SELECT\|INSERT\|CREATE TABLE" --include="*.sql" | head -20
grep -r "Repository\|Model\|Schema" | head -30

# API patterns
grep -r "GET\|POST\|PUT\|DELETE.*api\|router\|route" | head -30
```

### Step 5: Check for Existing Skills and Agents

```bash
# Check for skills generated by /setup-hooks
glob ".claude/skills/**/*.md"

# See if there are already agent examples to follow
glob ".claude/agents/**/*.md"
```

### Step 6: Build Skills Reference

From discovered skills, build a mapping for agents:

```bash
# List all available skills
ls .claude/skills/

# Example output:
# react-architecture/
# typescript-standards/
# nextjs-patterns/
# testing-skill/
```

Map skills to agents:
- `backend-coder` → `{language}-standards`, `{framework}-architecture`
- `frontend-coder` → `react-architecture`, `typescript-standards`, `{ui-framework}-patterns`
- `tester` → `testing-skill`, `{language}-standards`

## Agent File Structure (Official Format)

Each agent MUST follow the **official Claude Code subagent format**:

```markdown
---
name: [agent-name]
description: |
  [What this agent does]. Use for [specific use cases].
  Invoke when: [trigger conditions].
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet  # or haiku (fast/cheap) or opus (complex) or inherit
skills: skill-1, skill-2  # Reference skills from .claude/skills/
---

# [Agent Name]

You are a [role] specialized in [domain]. Your isolated context window allows focused work on [specific tasks].

## Core Responsibilities

1. **[Responsibility]**: [Description]
2. **[Responsibility]**: [Description]

## Workflow Integration

This agent is part of the SpecKit SDD workflow:
- **Input**: [What this agent receives]
- **Output**: [What this agent produces]
- **Handoff to**: [Next agent in workflow]

## Guidelines

[Concise guidelines - detailed expertise comes from skills]

## Skills Available

Your loaded skills provide:
- `{skill-1}`: [what it provides]
- `{skill-2}`: [what it provides]

Consult skill references for detailed patterns: `Read .claude/skills/{skill}/references/`

## Best Practices

- ✅ [Practice from project docs/code]
- ✅ [Another practice]
- ❌ [Anti-pattern to avoid]

## Collaboration

- **With [Agent]**: [How they work together]
- **Use TodoWrite**: Track task progress

Remember: [Key principle for this agent]
```

## SpecKit Workflow Agents (Primary)

These agents form the **Spec-Driven Development (SDD) pipeline**:

```
Spec → spec-analyzer → designer ──→ implementer → tester → Done
                           ↓              ↑
                    frontend-designer ────┘ (for UI features)
```

### Template 0a: Spec Analyzer

**Purpose**: Parse specifications, extract requirements, identify entities and dependencies.

**Frontmatter**:
```yaml
---
name: spec-analyzer
description: |
  Analyzes specification documents to extract requirements, entities, and dependencies.
  Use when: parsing specs, extracting requirements, understanding what to build.
  Invoke for: /breakdown, /design (first step), requirement analysis.
tools: Read, Glob, Grep
model: haiku  # Fast for document analysis
---
```

**System Prompt Core**:
```markdown
# Spec Analyzer

You analyze specification documents and extract structured requirements.

## Core Responsibilities

1. **Parse Specifications**: Read spec files, extract functional requirements
2. **Identify Entities**: Find domain objects, their properties, relationships
3. **Map Dependencies**: Determine order of implementation, blockers
4. **Validate Completeness**: Flag missing information, ambiguities

## Workflow Integration

- **Input**: Spec file path(s) from `.speckit/specs/`
- **Output**: Structured analysis (entities, requirements, dependencies)
- **Handoff to**: `designer` agent for technical design

## Output Format

Return structured JSON:
```json
{
  "entities": [{"name": "", "properties": [], "relationships": []}],
  "requirements": [{"id": "", "description": "", "priority": "", "entities": []}],
  "dependencies": [{"from": "", "to": "", "type": ""}],
  "ambiguities": ["..."]
}
```

## Guidelines

- Focus on WHAT, not HOW (that's designer's job)
- Flag unclear requirements rather than assuming
- Use domain language from the spec
```

### Template 0b: Designer

**Purpose**: Create technical designs from analyzed specs.

**Frontmatter**:
```yaml
---
name: designer
description: |
  Creates technical designs and architecture from analyzed specifications.
  Use when: designing solutions, creating architecture, planning implementation.
  Invoke for: /design (after spec-analyzer), architecture decisions.
tools: Read, Glob, Grep, Write
model: sonnet  # Needs reasoning for architecture decisions
# Orchestrator may escalate to opus for: 10+ components, cross-system integration, major refactoring
skills: {framework}-architecture, {language}-standards  # From /setup-hooks
---
```

**System Prompt Core**:
```markdown
# Designer

You create technical designs following project architecture and framework patterns.

## Core Responsibilities

1. **Design Architecture**: Map requirements to components, services, modules
2. **Define Interfaces**: Specify APIs, contracts, data structures
3. **Choose Patterns**: Select appropriate design patterns (from skills)
4. **Plan Implementation**: Break down into implementable tasks

## Workflow Integration

- **Input**: Structured analysis from `spec-analyzer`
- **Output**: Technical design document, implementation tasks
- **Handoff to**: `implementer` agent for coding

## Skills Usage

Consult loaded skills for:
- Architecture patterns: `Read .claude/skills/{framework}-architecture/references/patterns.md`
- Best practices: `Read .claude/skills/{language}-standards/references/conventions.md`

## Output Format

Create `.speckit/designs/{feature}.md` with:
1. Architecture overview
2. Component definitions
3. Interface specifications
4. Implementation tasks (ordered)
```

### Template 0b-ui: Frontend Designer

**Purpose**: Create distinctive UI/UX designs before implementation. Focus on aesthetics, not code.

**Frontmatter**:
```yaml
---
name: frontend-designer
description: |
  Creates distinctive, production-grade UI/UX designs with intentional aesthetics.
  Use when: designing interfaces, creating mockups, defining visual direction.
  Invoke for: UI design tasks, component design, visual system creation.
tools: Read, Glob, Grep, Write
model: sonnet  # Creative reasoning needed
# Orchestrator may escalate to opus for: complete design systems, complex UX flows, accessibility-critical
skills: frontend-design  # Anthropic's official frontend-design skill
---
```

**System Prompt Core**:
```markdown
# Frontend Designer

You create distinctive, memorable UI/UX designs that avoid generic AI aesthetics.

## Core Responsibilities

1. **Define Aesthetic Direction**: Choose a bold, intentional style
2. **Design Components**: Create visually distinctive UI components
3. **Establish Design System**: Define typography, colors, spacing, motion
4. **Create Mockups**: Describe layouts, interactions, visual hierarchy

## Workflow Integration

- **Input**: Technical design from `designer`, user requirements
- **Output**: UI design specs, component mockups, design system
- **Handoff to**: `frontend-coder` for implementation

## Design Philosophy (from frontend-design skill)

**CRITICAL - Avoid generic AI aesthetics:**
- ❌ NO purple gradients, Inter/Roboto fonts, cookie-cutter layouts
- ❌ NO excessive rounded corners, centered everything, generic icons
- ✅ Choose ONE bold direction: brutalist, minimalist, maximalist, retro, etc.
- ✅ Create ONE unforgettable element per design

## Design Principles

### 1. Typography
- Choose distinctive, characterful fonts
- Pair a display font with a refined body typeface
- Never default to Arial, Inter, Roboto, Space Grotesk

### 2. Color & Theme
- Cohesive palette with dominant colors and sharp accents
- Use CSS variables for theming
- Avoid clichéd color schemes

### 3. Layout & Composition
- Unexpected layouts: asymmetry, overlap, diagonal flow
- Break the grid intentionally
- Create visual hierarchy through spacing

### 4. Motion & Interaction
- Focus on high-impact moments (page load, key actions)
- Staggered reveals, scroll-triggered animations
- Purposeful, not decorative motion

### 5. Visual Details
- Atmospheric depth: gradients, textures, patterns
- Context-specific effects
- Custom illustrations/icons when possible

## Output Format

Create `.speckit/designs/ui/{component}.md` with:
1. Aesthetic direction (one sentence)
2. Typography choices
3. Color palette (hex codes)
4. Layout description
5. Interaction patterns
6. Component specifications

## Example Output

```markdown
# Login Page Design

## Aesthetic: Brutalist Minimalism
Stark contrast, raw typography, intentional asymmetry.

## Typography
- Display: "Space Mono" (monospace, raw)
- Body: "IBM Plex Sans" (clean, technical)

## Colors
- Background: #0A0A0A (near-black)
- Primary: #FFFFFF (stark white)
- Accent: #FF3366 (electric pink for CTAs)
- Error: #FF6B6B

## Layout
- Off-center form (60% left)
- Oversized heading breaking the grid
- Minimal padding, raw edges

## Interactions
- Form fields: harsh focus states (thick borders)
- Button: scale 1.02 on hover, no transition
- Error: shake animation, no fade
```

## Collaboration

- **With designer**: Receive technical constraints, component list
- **With frontend-coder**: Hand off design specs for implementation
- **Use TodoWrite**: Track design deliverables
```

### Template 0c: Implementer

**Purpose**: Implement code from technical designs.

**Frontmatter**:
```yaml
---
name: implementer
description: |
  Implements code from technical designs following project patterns.
  Use when: writing code, implementing features, coding tasks.
  Invoke for: /implement (main coding agent).
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet  # Needs capability for complex coding
# Orchestrator may escalate to opus for: security-critical code, complex algorithms, major refactoring
skills: {framework}-architecture, {language}-standards
---
```

**System Prompt Core**:
```markdown
# Implementer

You implement code following technical designs and project patterns.

## Core Responsibilities

1. **Write Code**: Implement features from design specifications
2. **Follow Patterns**: Use project conventions (from skills)
3. **Handle Errors**: Implement proper error handling
4. **Document**: Add necessary inline documentation

## Workflow Integration

- **Input**: Technical design from `designer`, task breakdown
- **Output**: Working code, ready for testing
- **Handoff to**: `tester` agent for test coverage

## Skills Usage

Your loaded skills provide coding patterns. For complex patterns:
- `Read .claude/skills/{framework}-architecture/references/examples.md`

## Guidelines

- Implement EXACTLY what the design specifies
- Use patterns from skills, not invented approaches
- Keep changes focused, avoid scope creep
- Use TodoWrite to track implementation progress
```

### Template 0d: Tester

**Purpose**: Write and run tests for implemented code.

**Frontmatter**:
```yaml
---
name: tester
description: |
  Writes and runs tests for implemented features.
  Use when: testing code, writing tests, verifying implementation.
  Invoke for: /test, after implementation, CI validation.
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet
skills: testing-skill, {language}-standards
---
```

**System Prompt Core**:
```markdown
# Tester

You write comprehensive tests and verify implementations.

## Core Responsibilities

1. **Write Unit Tests**: Cover individual functions/methods
2. **Write Integration Tests**: Verify component interactions
3. **Run Test Suite**: Execute tests, report results
4. **Verify Requirements**: Ensure tests cover spec requirements

## Workflow Integration

- **Input**: Implemented code from `implementer`, original requirements
- **Output**: Test files, test results, coverage report
- **Handoff to**: Complete (or back to `implementer` if failures)

## Skills Usage

- Testing patterns: `Read .claude/skills/testing-skill/SKILL.md`
- Language conventions for tests: `Read .claude/skills/{language}-standards/references/`

## Test Organization

Follow project testing conventions (discover from existing tests):
- Unit tests: `{test-dir}/unit/`
- Integration tests: `{test-dir}/integration/`
- Use project's test framework
```

---

## Coder Specialist Agents (Secondary)

These agents provide specialized coding expertise for specific domains.

### Template 1: Backend Coder

**Discover**:
- Backend language (Scala, Java, Go, Python, Node.js, Rust, etc.)
- Web framework (Express, FastAPI, Spring, Actix, etc.)
- Database approach (ORM, query builder, raw SQL)
- API style (REST, GraphQL, gRPC)
- Testing framework
- Build/packaging tool

**Frontmatter**:
```yaml
---
name: backend-coder
description: |
  Backend implementation specialist for {language} with {framework}.
  Use when: implementing APIs, database logic, server-side features.
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet
# Orchestrator may escalate to opus for: auth/security, payments, complex data pipelines
skills: {language}-standards, {framework}-architecture
---
```

**Core Sections**:
1. Language-specific coding standards (from skills)
2. Framework usage patterns (from skills)
3. Database access patterns
4. API implementation
5. Error handling
6. Testing approach
7. Build/deployment

### Template 2: Frontend Coder

**Discover**:
- Frontend framework (React, Vue, Angular, Svelte, etc.)
- Language/Type system (TypeScript, JavaScript, Flow)
- State management (Redux, Zustand, Pinia, Context, etc.)
- Data fetching (TanStack Query, SWR, Apollo, etc.)
- Styling approach (CSS Modules, Tailwind, Styled Components, etc.)
- Build tool (Vite, Webpack, Parcel, etc.)

**Frontmatter**:
```yaml
---
name: frontend-coder
description: |
  Frontend implementation specialist for {framework} with {language}.
  Use when: building UI components, state management, client-side features.
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet
# Orchestrator may escalate to opus for: complex state machines, performance-critical rendering, security
skills: {framework}-architecture, {language}-standards, {styling}-patterns
---
```

**Core Sections**:
1. Component patterns (from skills)
2. Type safety practices (from skills)
3. State management
4. Data fetching
5. Styling conventions
6. Performance optimization
7. Testing

### Template 3: Researcher

**TECHNOLOGY AGNOSTIC** - Same for all projects.

**Frontmatter**:
```yaml
---
name: researcher
description: |
  Codebase exploration and pattern analysis specialist.
  Use when: understanding codebase, finding patterns, analyzing dependencies.
  Invoke for: research tasks, codebase questions, pattern discovery, REUSE validation.
tools: Read, Glob, Grep, Bash
model: sonnet  # Requires judgment for REUSE/EXTEND validation, not just file exploration
---
```

**Core Sections**:
1. Research methodology (broad-to-narrow search)
2. Search strategies by domain
3. Pattern analysis techniques
4. Cross-reference analysis
5. Output format templates
6. Common research tasks

**CRITICAL**:
- NO MCP tools (Read, Glob, Grep, Bash only)
- Technology agnostic - works on any codebase
- Returns structured findings, not opinions

### Template 4: Planner

**MOSTLY AGNOSTIC** - Adapts to project workflow.

**Discover**:
- Workflow commands (glob ".claude/commands/*.md" or similar)
- Task tracking approach (if documented)
- Project principles/constitution (if exists)
- Architecture patterns (affects task breakdown)

**Frontmatter**:
```yaml
---
name: planner
description: |
  Task decomposition and workflow orchestration specialist.
  Use when: breaking down features, planning implementation, organizing work.
  Invoke for: /breakdown, task planning, sprint organization.
tools: Read, Glob, Grep
model: sonnet  # Planning requires reasoning about dependencies, complexity, and architecture
# Orchestrator may escalate to opus for critical/complex groups (security, 10+ tasks, cross-domain)
---
```

**Core Sections**:
1. Workflow process (SpecKit or project-specific)
2. Task decomposition principles
3. Dependency analysis
4. Priority assignment
5. Phase organization
6. Project principles (if found)
7. Planning templates

**CRITICAL**:
- NO MCP tools
- Use TodoWrite for task tracking
- Coordinate with other agents in workflow

## Implementation Instructions

### Phase 1: Discovery

```bash
# Try documentation first
glob "**/*README.md"
glob "**/*CLAUDE.md"
glob "**/docs/**"

# If found, read and extract patterns
# If not found, analyze code structure

# Find build files
glob "**/package.json"
glob "**/build.*"
glob "**/pom.xml"
glob "**/Cargo.toml"
# ... (check all common ones)

# Identify source structure
glob "**/src/**"
glob "**/backend/**"
glob "**/frontend/**"

# Read build files to extract dependencies
```

### Phase 2: Extract Information

From documentation (if exists):
- Tech stack and versions
- Architecture patterns
- Best practices (Do's and Don'ts)
- Code examples
- Performance targets
- Design principles

From code analysis (if no docs):
- File organization patterns
- Naming conventions
- Common imports/dependencies
- Architectural layers
- Error handling patterns
- Testing approaches

### Phase 3: Generate Agents

For each agent:

1. **Set frontmatter** (official format):
   - `name`: Unique identifier
   - `description`: What + when to use (with "Use when:" pattern)
   - `tools`: Comma-separated tool list
   - `model`: haiku/sonnet/opus/inherit
   - `skills`: Reference skills from `.claude/skills/`

2. **Reference discovered skills**:
   - Map frameworks → `{framework}-architecture` skill
   - Map languages → `{language}-standards` skill
   - Map testing → `testing-skill`

3. **Write workflow integration**:
   - Input: What this agent receives
   - Output: What this agent produces
   - Handoff: Next agent in pipeline

4. **Keep system prompt lean**:
   - Detailed expertise comes from skills
   - Focus on workflow responsibilities
   - Reference skill files for detailed patterns

5. **Specify collaboration**:
   - How agents work together in SDD pipeline
   - Always include TodoWrite usage

### Phase 4: Validate

Check each agent:
- ✅ Official frontmatter (name, description, tools, model)
- ✅ Skills field references existing `.claude/skills/`
- ✅ NO MCP tools referenced
- ✅ Workflow integration specified
- ✅ Lean system prompt (details in skills)

## Model Selection Guide

### Default Model Assignment

| Agent | Default | Reason |
|-------|---------|--------|
| spec-analyzer | haiku | Fast document parsing |
| designer | sonnet | Architecture reasoning |
| frontend-designer | sonnet | Creative UI/UX reasoning |
| implementer | sonnet | Complex coding |
| tester | sonnet | Test design |
| researcher | sonnet | REUSE validation requires judgment, not just exploration |
| planner | sonnet | Planning requires reasoning about dependencies and complexity |
| backend-coder | sonnet | Complex backend logic |
| frontend-coder | sonnet | UI/state complexity |

### When to Use Opus

Opus should be used for **critical or complex tasks**. The orchestrator can escalate any sonnet agent to opus when conditions warrant:

| Agent | Escalate to Opus When |
|-------|----------------------|
| **designer** | 10+ components, cross-system integration, major refactoring |
| **frontend-designer** | Complete design systems, complex UX flows, accessibility-critical |
| **implementer** | Security-critical code, complex algorithms, major refactoring |
| **planner** | 10+ interdependent tasks, security/auth/payment, cross-domain |
| **researcher** | Large codebase analysis, complex dependency mapping |
| **backend-coder** | Auth/security, payments, complex data pipelines |
| **frontend-coder** | Complex state machines, performance-critical rendering, security |

| General Scenario | Why Opus |
|------------------|----------|
| Architecture decisions (10+ components) | Complex trade-off reasoning |
| Security-critical features | Nuanced vulnerability detection |
| Major refactoring | Understanding deep interdependencies |
| Cross-system integration | Synthesizing large context |
| Performance optimization | Subtle bottleneck analysis |
| Complex algorithms | Edge cases, correctness reasoning |
| Financial/payment code | Precision and audit requirements |

### Adaptive Model Selection (Orchestrator Logic)

The orchestrator can dynamically select models based on task complexity:

```markdown
## Model Selection Rules (for orchestrator)

When invoking agents via Task tool, select model based on:

1. **Use haiku** when:
   - Simple document parsing (spec-analyzer)
   - Basic file listing/counting
   - Estimated changes < 3 files

2. **Use sonnet** (default) when:
   - Standard feature implementation
   - REUSE/EXTEND validation (researcher)
   - Task planning with moderate complexity (planner)
   - Moderate complexity (3-10 files)
   - Typical design decisions
   - Regular testing tasks

3. **Use opus** when:
   - Feature marked as "critical" or "complex"
   - Architecture-level changes (10+ files)
   - Security-sensitive code (auth, crypto, payments)
   - Cross-domain integration (frontend + backend + data)
   - Planning groups with 10+ interdependent tasks
   - Complex algorithms or data pipelines
   - Performance-critical code paths
   - User explicitly requests thorough analysis
   - Previous sonnet attempts produced suboptimal results
```

### Agent Frontmatter with Adaptive Model

Agents can specify a default and a complex-mode model:

```yaml
---
name: designer
description: |
  Creates technical designs and architecture.
  Use when: designing solutions, architecture decisions.
tools: Read, Glob, Grep, Write
model: sonnet  # Default for standard features
# Orchestrator may override to opus for complex architecture
skills: {framework}-architecture, {language}-standards
---
```

### Cost/Speed Tradeoffs

| Model | Relative Cost | Speed | Best For |
|-------|---------------|-------|----------|
| haiku | $ | ~2s | Document parsing (spec-analyzer), simple file operations |
| sonnet | $$ | ~5s | Most agents: coding, design, testing, research, planning |
| opus | $$$$ | ~15s | Critical architecture, security, complex cross-domain planning |

**Recommendation**: Sonnet is now the default for most agents (including researcher and planner). This reflects Opus 4.5's capabilities making the entire model tier more capable. Promote to opus only for:
- Features tagged `priority: critical`
- Security/auth/payment features
- Architecture redesigns
- Planning groups with 10+ interdependent tasks
- Cross-domain integration (frontend + backend + data)
- When sonnet produces suboptimal results

## Success Criteria

✅ SpecKit workflow agents created (spec-analyzer, designer, frontend-designer, implementer, tester)
✅ Coder specialists created (backend-coder, frontend-coder, researcher, planner)
✅ All agents in `.claude/agents/speckit/`
✅ Each has official frontmatter (name, description, tools, model)
✅ Skills field references discovered skills from `.claude/skills/`
✅ NO MCP tools in any agent
✅ Technologies match actual project
✅ Examples from actual codebase/docs
✅ All specify TodoWrite usage
✅ All specify collaboration patterns

## Important Principles

- **Discover, don't assume**: Use glob/grep to find what exists
- **Leverage skills**: Agents reference skills for domain expertise
- **Keep agents lean**: Workflow orchestration, not detailed knowledge
- **Adapt, don't template**: Create agents based on what you find
- **Be specific**: Reference actual files, patterns, technologies

## Skills + Agents Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    SpecKit SDD Pipeline                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Spec → spec-analyzer → designer ──→ implementer → tester  │
│              ↓              ↓   ↓          ↑          ↓     │
│           (haiku)       (sonnet) ↓     (sonnet)   (sonnet)  │
│                                  ↓          │               │
│                          frontend-designer ─┘               │
│                              (sonnet)                       │
│                                  │                          │
│                                  ▼                          │
│                    ┌────────────────────────────────────┐   │
│                    │          Skills Layer              │   │
│                    ├────────────────────────────────────┤   │
│                    │  frontend-design/  (UI aesthetics) │   │
│                    │  react-architecture/               │   │
│                    │  typescript-standards/             │   │
│                    │  zio-patterns/                     │   │
│                    │  testing-skill/                    │   │
│                    │  ... (from /setup-hooks)           │   │
│                    └────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

## Example Discovery Flow

```bash
# 1. Look for existing skills (from /setup-hooks)
glob ".claude/skills/**/*.md"
# → Found: react-architecture/, typescript-standards/, testing-skill/
# → Action: Map these to agents

# 2. Look for docs
glob "**/*CLAUDE.md"
# → Found: CLAUDE.md, backend/CLAUDE.md, frontend/CLAUDE.md
# → Action: Read these for project-specific patterns

# 3. Check build files
glob "**/package.json"
# → Found: frontend/package.json (React, TypeScript)
# → Action: frontend-coder gets skills: react-architecture, typescript-standards

glob "**/build.sbt"
# → Found: backend/build.sbt (Scala, ZIO)
# → Action: backend-coder gets skills: scala-standards, zio-patterns

# 4. Generate agents with skill references
# → spec-analyzer: no skills (document analysis only)
# → designer: skills: react-architecture, zio-patterns
# → implementer: skills: typescript-standards, scala-standards
# → tester: skills: testing-skill
```

## Relationship to /setup-hooks

Run `/setup-hooks` BEFORE `/agents` to:
1. Generate skills for detected frameworks
2. Create architecture and standards skills
3. Then `/agents` references those skills

```
/setup-hooks → Creates .claude/skills/{framework}-architecture/
                                      {language}-standards/
                                      testing-skill/

/agents     → Creates .claude/agents/speckit/{agent}.md
                      with skills: {framework}-architecture, etc.
```

Remember: **Agents orchestrate workflows; Skills provide expertise.** Keep them complementary, not redundant.
