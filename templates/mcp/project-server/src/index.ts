#!/usr/bin/env node
/**
 * {{PROJECT_NAME}} MCP Server
 *
 * Model Context Protocol server for project automation:
 * - Service management (start/stop backend, frontend, etc.)
 * - Log monitoring
 * - Browser automation (Playwright)
 * - API testing
 *
 * Generated by /speckit.mcp
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from "@modelcontextprotocol/sdk/types.js";

import { config } from "./config.js";
import * as processTools from "./tools/process.js";
import * as browserTools from "./tools/browser.js";
import * as apiTools from "./tools/api.js";

// Define available tools
const tools: Tool[] = [
  // ============= Process Management =============
  {
    name: "start_service",
    description: "Start a service (backend, frontend, api, etc.)",
    inputSchema: {
      type: "object",
      properties: {
        name: {
          type: "string",
          description: "Service name to start",
          enum: config.services.map((s) => s.name),
        },
      },
      required: ["name"],
    },
  },
  {
    name: "stop_service",
    description: "Stop a running service",
    inputSchema: {
      type: "object",
      properties: {
        name: {
          type: "string",
          description: "Service name to stop",
          enum: config.services.map((s) => s.name),
        },
      },
      required: ["name"],
    },
  },
  {
    name: "stop_all",
    description: "Stop all running services",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "services_status",
    description: "Get status of all configured services",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "service_logs",
    description: "Get logs from a service",
    inputSchema: {
      type: "object",
      properties: {
        name: {
          type: "string",
          description: "Service name",
          enum: config.services.map((s) => s.name),
        },
        lines: {
          type: "number",
          description: "Number of lines to retrieve (default: 50)",
        },
        filter: {
          type: "string",
          description: "Regex pattern to filter logs",
        },
      },
      required: ["name"],
    },
  },
  {
    name: "health_check",
    description: "Check if a service is healthy",
    inputSchema: {
      type: "object",
      properties: {
        name: {
          type: "string",
          description: "Service name to check",
          enum: config.services.map((s) => s.name),
        },
      },
      required: ["name"],
    },
  },
  {
    name: "start_docker",
    description: "Start Docker Compose services (db, redis, etc.)",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "stop_docker",
    description: "Stop Docker Compose services",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },

  // ============= Browser Automation =============
  {
    name: "browser_open",
    description: "Open a URL in the browser (initializes browser if needed)",
    inputSchema: {
      type: "object",
      properties: {
        url: {
          type: "string",
          description: "URL to open (relative or absolute)",
        },
      },
      required: ["url"],
    },
  },
  {
    name: "browser_close",
    description: "Close the browser",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "browser_screenshot",
    description: "Take a screenshot of the page or element",
    inputSchema: {
      type: "object",
      properties: {
        selector: {
          type: "string",
          description: "CSS selector for specific element (optional, full page if omitted)",
        },
      },
    },
  },
  {
    name: "browser_click",
    description: "Click an element",
    inputSchema: {
      type: "object",
      properties: {
        selector: {
          type: "string",
          description: "CSS selector for element to click",
        },
      },
      required: ["selector"],
    },
  },
  {
    name: "browser_fill",
    description: "Fill an input field",
    inputSchema: {
      type: "object",
      properties: {
        selector: {
          type: "string",
          description: "CSS selector for input field",
        },
        value: {
          type: "string",
          description: "Value to fill",
        },
      },
      required: ["selector", "value"],
    },
  },
  {
    name: "browser_type",
    description: "Type text character by character (for autocomplete)",
    inputSchema: {
      type: "object",
      properties: {
        selector: {
          type: "string",
          description: "CSS selector for input field",
        },
        text: {
          type: "string",
          description: "Text to type",
        },
      },
      required: ["selector", "text"],
    },
  },
  {
    name: "browser_get_text",
    description: "Get text content of an element",
    inputSchema: {
      type: "object",
      properties: {
        selector: {
          type: "string",
          description: "CSS selector",
        },
      },
      required: ["selector"],
    },
  },
  {
    name: "browser_wait_for",
    description: "Wait for an element to appear",
    inputSchema: {
      type: "object",
      properties: {
        selector: {
          type: "string",
          description: "CSS selector to wait for",
        },
        timeout: {
          type: "number",
          description: "Timeout in milliseconds (default: 10000)",
        },
      },
      required: ["selector"],
    },
  },
  {
    name: "browser_exists",
    description: "Check if an element exists",
    inputSchema: {
      type: "object",
      properties: {
        selector: {
          type: "string",
          description: "CSS selector",
        },
      },
      required: ["selector"],
    },
  },
  {
    name: "browser_url",
    description: "Get the current page URL",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "browser_check_errors",
    description: "Check for visible errors on the page",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "browser_select",
    description: "Select an option from a dropdown",
    inputSchema: {
      type: "object",
      properties: {
        selector: {
          type: "string",
          description: "CSS selector for select element",
        },
        value: {
          type: "string",
          description: "Option value to select",
        },
      },
      required: ["selector", "value"],
    },
  },
  {
    name: "browser_press",
    description: "Press a keyboard key (Enter, Tab, Escape, etc.)",
    inputSchema: {
      type: "object",
      properties: {
        key: {
          type: "string",
          description: "Key to press",
        },
      },
      required: ["key"],
    },
  },

  // ============= API Testing =============
  {
    name: "api_get",
    description: "Make a GET request",
    inputSchema: {
      type: "object",
      properties: {
        endpoint: {
          type: "string",
          description: "API endpoint (relative or absolute URL)",
        },
        headers: {
          type: "object",
          description: "Additional headers",
        },
      },
      required: ["endpoint"],
    },
  },
  {
    name: "api_post",
    description: "Make a POST request",
    inputSchema: {
      type: "object",
      properties: {
        endpoint: {
          type: "string",
          description: "API endpoint",
        },
        body: {
          type: "object",
          description: "Request body (JSON)",
        },
        headers: {
          type: "object",
          description: "Additional headers",
        },
      },
      required: ["endpoint"],
    },
  },
  {
    name: "api_put",
    description: "Make a PUT request",
    inputSchema: {
      type: "object",
      properties: {
        endpoint: {
          type: "string",
          description: "API endpoint",
        },
        body: {
          type: "object",
          description: "Request body (JSON)",
        },
        headers: {
          type: "object",
          description: "Additional headers",
        },
      },
      required: ["endpoint"],
    },
  },
  {
    name: "api_delete",
    description: "Make a DELETE request",
    inputSchema: {
      type: "object",
      properties: {
        endpoint: {
          type: "string",
          description: "API endpoint",
        },
        headers: {
          type: "object",
          description: "Additional headers",
        },
      },
      required: ["endpoint"],
    },
  },
  {
    name: "api_health",
    description: "Check if an endpoint is healthy",
    inputSchema: {
      type: "object",
      properties: {
        url: {
          type: "string",
          description: "URL to check",
        },
        expectedStatus: {
          type: "number",
          description: "Expected HTTP status (default: 200)",
        },
      },
      required: ["url"],
    },
  },
  {
    name: "api_test",
    description: "Test an endpoint against expected values",
    inputSchema: {
      type: "object",
      properties: {
        method: {
          type: "string",
          enum: ["GET", "POST", "PUT", "PATCH", "DELETE"],
        },
        endpoint: {
          type: "string",
        },
        body: {
          type: "object",
        },
        expectedStatus: {
          type: "number",
        },
        expectedBody: {
          type: "object",
        },
      },
      required: ["method", "endpoint"],
    },
  },
];

// Create server
const server = new Server(
  {
    name: `${config.name}-mcp-server`,
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// List tools handler
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools,
}));

// Call tool handler
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    let result: unknown;

    switch (name) {
      // Process tools
      case "start_service":
        result = await processTools.startService(args?.name as string);
        break;
      case "stop_service":
        result = await processTools.stopService(args?.name as string);
        break;
      case "stop_all":
        result = await processTools.stopAllServices();
        break;
      case "services_status":
        result = processTools.getServicesStatus();
        break;
      case "service_logs":
        result = processTools.getServiceLogs(
          args?.name as string,
          args?.lines as number,
          args?.filter as string
        );
        break;
      case "health_check":
        result = await processTools.checkHealth(args?.name as string);
        break;
      case "start_docker":
        result = await processTools.startDocker();
        break;
      case "stop_docker":
        result = await processTools.stopDocker();
        break;

      // Browser tools
      case "browser_open":
        result = await browserTools.navigate(args?.url as string);
        break;
      case "browser_close":
        result = await browserTools.closeBrowser();
        break;
      case "browser_screenshot":
        result = await browserTools.screenshot(args?.selector as string);
        break;
      case "browser_click":
        result = await browserTools.click(args?.selector as string);
        break;
      case "browser_fill":
        result = await browserTools.fill(args?.selector as string, args?.value as string);
        break;
      case "browser_type":
        result = await browserTools.type(args?.selector as string, args?.text as string);
        break;
      case "browser_get_text":
        result = await browserTools.getText(args?.selector as string);
        break;
      case "browser_wait_for":
        result = await browserTools.waitFor(args?.selector as string, args?.timeout as number);
        break;
      case "browser_exists":
        result = await browserTools.exists(args?.selector as string);
        break;
      case "browser_url":
        result = await browserTools.getCurrentUrl();
        break;
      case "browser_check_errors":
        result = await browserTools.checkForErrors();
        break;
      case "browser_select":
        result = await browserTools.select(args?.selector as string, args?.value as string);
        break;
      case "browser_press":
        result = await browserTools.press(args?.key as string);
        break;

      // API tools
      case "api_get":
        result = await apiTools.get(args?.endpoint as string, {
          headers: args?.headers as Record<string, string>,
        });
        break;
      case "api_post":
        result = await apiTools.post(args?.endpoint as string, args?.body, {
          headers: args?.headers as Record<string, string>,
        });
        break;
      case "api_put":
        result = await apiTools.put(args?.endpoint as string, args?.body, {
          headers: args?.headers as Record<string, string>,
        });
        break;
      case "api_delete":
        result = await apiTools.del(args?.endpoint as string, {
          headers: args?.headers as Record<string, string>,
        });
        break;
      case "api_health":
        result = await apiTools.healthCheck(
          args?.url as string,
          args?.expectedStatus as number
        );
        break;
      case "api_test":
        result = await apiTools.testEndpoint(
          args?.method as string,
          args?.endpoint as string,
          {
            body: args?.body,
            expectedStatus: args?.expectedStatus as number,
            expectedBody: args?.expectedBody,
          }
        );
        break;

      default:
        throw new Error(`Unknown tool: ${name}`);
    }

    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(result, null, 2),
        },
      ],
    };
  } catch (error) {
    return {
      content: [
        {
          type: "text",
          text: `Error: ${error}`,
        },
      ],
      isError: true,
    };
  }
});

// Cleanup on exit
process.on("SIGINT", async () => {
  await processTools.stopAllServices();
  await browserTools.closeBrowser();
  process.exit(0);
});

process.on("SIGTERM", async () => {
  await processTools.stopAllServices();
  await browserTools.closeBrowser();
  process.exit(0);
});

// Start server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error(`${config.name} MCP Server running on stdio`);
}

main().catch(console.error);
