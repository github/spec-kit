Think about the last time you asked an AI tool to write code. It probably gave you something that looked correct but didn't quite work. That's where vibe coding falls short. But it might not be a problem with the particular model you're using. It's most likely because of lack of specification clarity. That is where specdriven development comes to rescue.
GitHub just released a new open-source toolkit called SpecKit, which completely changes the game. Today we're going to look at SpecKit, see how it works, and I will show you a little demo how to use it, and we'll find out if this is really the future of coding. In traditional development, you write code, then document what it does.
In specdriven development, you do the opposite. You write a specification, a living executable artifact, and that spec defines what you intend to build. From there, all stakeholders and AI tools align around the same source of truth. This approach closes the gaps between intent and implementation and leads to cleaner, safer, and more reliable code.
The main idea is that language models are great at patterns, but not so great at reading your mind. Broad prompts like, "Add photo sharing to my app," leaves the AI guessing thousands of details, most of which never match your real intent. Specdriven development eliminates that guesswork. It gives AI clear structured guidance so it builds exactly what you want.
Few months ago, Amazon launched Kira, which was the first framework to really focus on specdriven development. And James did an excellent deep dive on that in a separate video if you want to check it out here. But now there's a new player in town, SpecKit. It is GitHub's open-source toolkit for specd driven development with AI coding agents.
It features a CLI tool, templates, and steering prompts designed to work with tools like GitHub Code Pilot, Claude Code, and Gemini CLI. It aims to transform your ad hoc prompting into a structured, verifiable development workflow. Here's how it works. Specit organizes your development into four gated phases, each with a validation checkpoint before moving forward.
The first phase is specify. This is where you describe what you want to build and why focusing on user journeys and outcomes. The AI agent uses that to generate a detailed spec which also evolves as your understanding grows. The second phase is plan. This phase defines the stack and architectural constraints. You tell the agent your specifications and it constructs a technical plan that honors those constraints.
Third phase is tasks. This is where the spec and plan is broken down into small actionable tasks. This gives you manageable testable units that AI can implement one by one. And the fourth phase is implement. This is where AI tackles tasks incrementally. You can review each change before implementation instead of running bulky code dumps.
That way the model knows what to build, how to build it, and where to focus. You can verify and refine this at each step. It gives you total granular control over execution. This toolkit was born out of frustration with the coding models behaving like a search engine instead of a literal-minded pair programmer. At its core, it's a shift towards intent as the source of truth.
Instead of code, the spec becomes the authorative artifact and the models constantly circle back to the spec document for guidance on how to proceed. So now I'm going to show you with a little project how we can use specit in our own projects. To kick things off, you just need to run this command in your terminal specifying your project name and then choose which agentic framework to use.
In this demo, I will be using GitHub copilot. The kit will initialize all the necessary files for your project and then you can proceed to open the workspace in your code editor. The first thing you will see when you open the code editor is that specit has created this script folder and templates folder. And these are just boilerplate spec templates which are used to generate your actual spec files.
And the scripts are the ones that execute and prepare those documents. We don't have to change anything here. We can just go ahead and prepare our project by typing specify followed by our prompt. This initial prompt should be an overall description of your project. what the goal is, what the basic features are, and maybe even describe what a simple user journey looks like.
In this example, I will be creating a simple Pokedex team builder where I can search for Pokemon and add them to my team. I will also be using Gro Code Fast one as the base model for this project. So, let's go ahead and run the command. And once that's done, you will see that specit has created a new branch for this development and it has also created a spec markdown file.
In this file, we see that the model has successfully understood the assignment and created a primary user story along with acceptance scenarios. I also like that it thinks about edge cases as well and other potential roadblocks. And whenever the model comes to a situation where it can't decide on a path forward, it will add this block titled needs clarification.
So you can specify the requirements yourself. And we can also see here that it has crafted some functional requirements and key entities as well. Honestly, this is super cool because I would be too lazy to write out all these specifics for the model to follow. So, it's good that spec kit is able to guide the model to craft all of this for us.
And remember, if you ever need to change something here or decide on a totally different direction to take, this is the file where you can make those edits. But if we're happy with the spec file, next we can proceed to the plan phase. And here we should more concretely describe the tech stack of our application along with other details that we deem necessary.
Here I just pasted in some basic technical requirements for the project along with some other helpful commands like using a debounce on the Pokemon search endpoint so we don't overwhelm the API. And once you're happy with all of that, let's execute the plan command. And you can see here that specit gets more detailed.
It adds a data model and a research document as well as contracts for the object types which is super cool. And in the data model file, it even crafted a zod schema object. But I really love the research document because here we can see the ration behind the model choosing specific frameworks and it also gives us explanations about its reasoning along with other considerations for alternative solutions and it also respects the text stack choices you give it plus it tries to think of other necessities which you might not have
considered as well. So that is really powerful. So then we move on to the plan file which has laid out all the development phases in concrete steps and it has also ticked the ones that are already completed. This all looks very good to me. So now we can move on to the next phase, the task execution phase. Now we already have the spec and plan in place.
So for the tasks command, we can just start by asking the model to create an MVP version of our project. And this is where the magic happens. SpecKit will now create a very detailed tasks list which outlines step by step what we need to do to get to our development goal. Let's open up the tasks list. And we can see here that it has given every task a unique number.
And that keeps everything well and organized. So you can execute tasks in order and review them as you go. I see here that tasks one to four are dedicated to setting up the environment. So let's go ahead and ask the model to execute those. There is no slash command for this phase, but as I understand the recommended way to proceed is to write implement followed by the task numbers to tell the model which tasks to execute at the specific given command.
So first let's run the setup tasks so you can also keep track of the progress. So from here on out it's a very free flow approach of just asking the model which tasks to implement and then just following along, seeing the progress and iterating on the process. And once they're done, we can see that the model has also ticked them as completed.
I noticed that in this particular template that they have, it very much likes the test-driven development approach where it writes the tests first and then implements the features. You can probably change that in the spec or the plan if you want to go for a different development approach. So after a few commands and iterations, my model has finished implementing all of the tasks. And here's the result.
As you can see, we have a nice little functioning Pokedex where I can search for any Pokemon and add them to my team. The API seems to be working perfectly. And the project also looks very clean. It uses Chats and UI elements as I prompted it to do. And by the looks of everything, it's very well and functional. So, there you have it.
We just vibecoded a nice little web project using SpecKit. I hope by now you see how this meticulous specdriven development approach can help improve the AI model's ability to craft a cleaner, more refined code. It also gives you more precision to steer the model in the direction you want to go.
And I do have to mention that although SpecKit is designed to work with most of the coding models, the choice of the coding model still makes a difference. While testing out this tool, I also tried scaffolding a project using GPT4.1 and it didn't give me as good of a result as when I used the Grock model. So, choosing the right coding model is still necessary to achieve the best results.
It's clear that specdriven development is a paradigm we'll be seeing much more of in the future of coding. But what are your thoughts about specit? Are you using specdriven development in your coding practices? Let us know in the comments down below. And folks, if you like these types of technical breakdowns, let us know by smashing that like button underneath the video.