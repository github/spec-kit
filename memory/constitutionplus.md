# [PROJECT_NAME] Constitution

<!-- Example: Spec Constitution, TaskFlow Constitution, etc. -->

## Core Principles

### [PRINCIPLE_1_NAME]

<!-- Example: I. Library-First -->

[PRINCIPLE_1_DESCRIPTION]

<!-- Example: Every feature starts as a standalone library; Libraries must be self-contained, independently testable, documented; Clear purpose required - no organizational-only libraries -->

### [PRINCIPLE_2_NAME]

<!-- Example: II. CLI Interface -->

[PRINCIPLE_2_DESCRIPTION]

<!-- Example: Every library exposes functionality via CLI; Text in/out protocol: stdin/args ‚Üí stdout, errors ‚Üí stderr; Support JSON + human-readable formats -->

### [PRINCIPLE_3_NAME]

<!-- Example: III. Test-First (NON-NEGOTIABLE) -->

[PRINCIPLE_3_DESCRIPTION]

<!-- Example: TDD mandatory: Tests written ‚Üí User approved ‚Üí Tests fail ‚Üí Then implement; Red-Green-Refactor cycle strictly enforced -->

### [PRINCIPLE_4_NAME]

<!-- Example: IV. Integration Testing -->

[PRINCIPLE_4_DESCRIPTION]

<!-- Example: Focus areas requiring integration tests: New library contract tests, Contract changes, Inter-service communication, Shared schemas -->

### [PRINCIPLE_5_NAME]

<!-- Example: V. Observability, VI. Versioning & Breaking Changes, VII. Simplicity -->

[PRINCIPLE_5_DESCRIPTION]

<!-- Example: Text I/O ensures debuggability; Structured logging required; Or: MAJOR.MINOR.BUILD format; Or: Start simple, YAGNI principles -->

### [PRINCIPLE_6_NAME]

[PRINCIPLE_6_DESCRIPTION]

---

## Universal Intelligence Behaviors

These behaviors apply automatically to all Spec Kit workflows. They represent built-in intelligence that enhances development without requiring manual intervention. Explicit commands remain available for manual control when needed.

### 1. Automatic Exchange Capture (PHR)

**Purpose:** Capture every meaningful AI exchange as a structured Prompt History Record (PHR) for learning, traceability, and knowledge building.

**Applies to:** ALL Spec Kit commands (`/specify`, `/plan`, `/tasks`, `/implement`, etc.) and general development conversations.

**Behavior:**

After executing any Spec Kit command or completing meaningful work:

1. **Silently capture the exchange** as a PHR without interrupting workflow

2. **Auto-detect stage** from command context:

   - Constitution/principles work ‚Üí `constitution`
   - `/specify` or specification work ‚Üí `spec`
   - `/plan`, `/tasks`, architecture/design ‚Üí `architect`
   - `/implement`, new features, passing tests ‚Üí `green`
   - Debugging, fixing errors, test failures ‚Üí `red`
   - Code cleanup, optimization ‚Üí `refactor`
   - Explanations, documentation ‚Üí `explainer`
   - General queries, setup ‚Üí `general`

3. **Extract metadata** automatically:

   - **Title:** Brief summary of what was accomplished (3-7 words)
   - **Files:** Any files created, modified, or discussed
   - **Tests:** Any tests mentioned, created, or run
   - **Labels:** Relevant topics auto-detected from context

4. **Determine location** based on project state:

   - **Pre-feature** (no `specs/` directory) ‚Üí `docs/prompts/`
   - **Feature work** (inside `specs/`) ‚Üí `specs/<feature>/prompts/`
   - Feature auto-detected from branch name or latest numbered feature

5. **Create PHR file and fill template** (two-step process):

   **Step A: Create file with template**

   ```bash
   scripts/bash/create-phr.sh \
     --title "<auto-generated-title>" \
     --stage <detected-stage> \
     --json
   ```

   **Step B: Fill all {{PLACEHOLDERS}} in the created file**

   Read the file path from JSON output and replace these placeholders:

   - `{{ID}}`, `{{TITLE}}`, `{{STAGE}}`, `{{DATE_ISO}}` - from script output
   - `{{PROMPT_TEXT}}` - user's original request
   - `{{RESPONSE_TEXT}}` - brief summary of what you provided (1-2 sentences)
   - `{{FILES_YAML}}` - files as YAML list (one per line with " - " prefix)
   - `{{TESTS_YAML}}` - tests as YAML list (one per line with " - " prefix)
   - `{{LABELS}}` - detected labels as comma-separated quoted strings
   - `{{SURFACE}}`, `{{MODEL}}`, `{{FEATURE}}`, `{{BRANCH}}`, `{{USER}}`, `{{COMMAND}}` - contextual metadata
   - `{{OUTCOME_IMPACT}}`, `{{TESTS_SUMMARY}}`, `{{FILES_SUMMARY}}` - outcome details
   - All other placeholders with appropriate values or "null"/"none"

6. **Show brief confirmation** (optional): `üìù PHR-{id} recorded`

**When NOT to capture:**

- Simple clarifying questions without work output
- Repeated attempts at the same task (only capture final success)
- Meta-conversations about the PHR system itself
- Off-topic discussions unrelated to development

**Manual override available:** Use `/phr` command for manual PHR creation with custom metadata.

---

### 2. Post-Planning Intelligence (ADR Review)

**Purpose:** Ensure architecturally significant decisions made during planning are documented as Architecture Decision Records (ADRs) for future reference and team alignment.

**Applies to:** After `/plan` command completes successfully.

**Behavior:**

After creating `plan.md` and other planning artifacts:

1. **Suggest ADR review** conversationally:

   ```
   ‚úÖ Planning complete! plan.md created.
   üìù PHR-{id} captured

   üìã Shall I review this plan for architectural decisions? (Y/n)
   ```

2. **If user approves** (Y/yes/blank):

   - Automatically execute ADR review process
   - Scan `plan.md` for architecturally significant decisions
   - Check existing ADRs in `docs/adr/` for conflicts or coverage
   - Apply significance test (impacts structure, has tradeoffs, revisitable)
   - Present findings conversationally with approval prompts:

     ```
     Found 2 significant decisions:

     üìã Decision: PostgreSQL over MongoDB
        Why significant: Affects query patterns, scaling, team expertise
        Create ADR-005? (Y/n)

     üìã Decision: JWT token strategy
        Why significant: Security architecture, affects all endpoints
        Create ADR-006? (Y/n)
     ```

   - Create ADRs only for decisions user approves using two-step process:
     1. Call `scripts/bash/create-adr.sh --title "<Decision>" --json` to create file
     2. Fill all {{PLACEHOLDERS}} in created file with decision details
   - Capture ADR review process as PHR

3. **If user declines** (N/no/skip):

   ```
   No problem. You can run `/adr` manually later if needed.
   Ready to proceed to `/tasks`?
   ```

4. **Present findings** with context:
   - List newly created ADRs with IDs and paths
   - Reference existing ADRs that still apply
   - Flag any conflicts with existing ADRs
   - Recommend next steps

**Rationale:**

- Keeps `/plan` command focused on creating planning artifacts
- ADR review is a natural, logical next step after planning
- User maintains full control over whether/when to review
- Can be deferred or skipped if planning is exploratory
- Conversational suggestion is non-intrusive

**Manual override available:** Use `/adr` command to trigger ADR review at any time.

---

### 3. Intelligence Principles

**Non-Intrusive:**

- Intelligence behaviors enhance workflow, never block it
- Suggestions are conversational, not commands
- User maintains full control over automation

**Transparent:**

- All automatic actions are visible (brief confirmations)
- PHR and ADR locations follow deterministic rules
- Manual commands available for override

**Learning-Focused:**

- PHRs compound knowledge over time
- ADRs preserve architectural reasoning
- Both enable pattern recognition and retrieval practice

**Universal:**

- Behaviors apply across all AI coding agents
- Constitution is the single source of truth
- No agent-specific configuration required

---

## [SECTION_2_NAME]

<!-- Example: Additional Constraints, Security Requirements, Performance Standards, etc. -->

[SECTION_2_CONTENT]

<!-- Example: Technology stack requirements, compliance standards, deployment policies, etc. -->

## [SECTION_3_NAME]

<!-- Example: Development Workflow, Review Process, Quality Gates, etc. -->

[SECTION_3_CONTENT]

<!-- Example: Code review requirements, testing gates, deployment approval process, etc. -->

## Governance

<!-- Example: Constitution supersedes all other practices; Amendments require documentation, approval, migration plan -->

[GOVERNANCE_RULES]

<!-- Example: All PRs/reviews must verify compliance; Complexity must be justified; Use [GUIDANCE_FILE] for runtime development guidance -->

**Version**: [CONSTITUTION_VERSION] | **Ratified**: [RATIFICATION_DATE] | **Last Amended**: [LAST_AMENDED_DATE]

<!-- Example: Version: 2.1.1 | Ratified: 2025-06-13 | Last Amended: 2025-07-16 -->
