# .NET Corporate Guidelines

**Tech Stack**: .NET 6+, C#, ASP.NET Core, Backend Services, Microservices

**Auto-detected from**: `*.csproj`, `*.sln`, or `*.cs` files

## 1. Scaffolding

### Creating New ASP.NET Core Applications

**Corporate Command**:

```bash
dotnet new YOUR_ORG_template -n MyService
```

**Example**:

```bash
dotnet new acmecorp-webapi -n UserService
dotnet new acmecorp-minimal-api -n OrderService
```

**Options**:

- `acmecorp-webapi` - Standard Web API with controllers
- `acmecorp-minimal-api` - Minimal API (lightweight)
- `acmecorp-worker` - Background worker service
- `acmecorp-blazor` - Blazor WebAssembly app

**Installation** (if not already installed):

```bash
dotnet new --install Acmecorp.Templates::1.0.0 --nuget-source https://nuget.acmecorp.com/v3/index.json
```

**DO NOT USE**:

```bash
# ❌ Default templates - bypass corporate configuration
dotnet new webapi -n MyService
```

### Project Structure

**Standard structure** (generated by corporate templates):

```text
src/
├── UserService.Api/                    # Web API project
│   ├── Controllers/
│   ├── Program.cs
│   ├── appsettings.json
│   └── appsettings.Production.json
├── UserService.Application/             # Business logic
│   ├── Services/
│   ├── DTOs/
│   ├── Interfaces/
│   └── Validators/
├── UserService.Domain/                  # Domain models
│   ├── Entities/
│   ├── Enums/
│   └── ValueObjects/
├── UserService.Infrastructure/          # Data access, external services
│   ├── Data/
│   │   ├── ApplicationDbContext.cs
│   │   └── Migrations/
│   ├── Repositories/
│   └── ExternalServices/
└── UserService.Tests/                   # Tests
    ├── UnitTests/
    └── IntegrationTests/
```

## 2. Package Registry

### NuGet Configuration

**File**: `nuget.config` (in solution root)

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="AcmeCorp" value="https://nuget.acmecorp.com/v3/index.json" />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
  </packageSources>
  <packageSourceCredentials>
    <AcmeCorp>
      <add key="Username" value="%NUGET_USERNAME%" />
      <add key="ClearTextPassword" value="%NUGET_PASSWORD%" />
    </AcmeCorp>
  </packageSourceCredentials>
</configuration>
```

**Authentication** (environment variables):

```bash
export NUGET_USERNAME=your-username
export NUGET_PASSWORD=your-api-key
```

**Alternative** (using Azure Artifacts):

```xml
<packageSources>
  <add key="AcmeCorp" value="https://pkgs.dev.azure.com/acmecorp/_packaging/acmecorp-feed/nuget/v3/index.json" />
</packageSources>
```

## 3. Mandatory Libraries

### Corporate ASP.NET Core Starter

**MUST USE**: Corporate NuGet package with pre-configured dependencies

**Package**:

```bash
dotnet add package Acmecorp.AspNetCore.Starter
```

**What it includes**:

- Corporate authentication/authorization
- Centralized logging (Serilog with structured JSON)
- Health checks and metrics
- Exception handling middleware
- CORS configuration
- Request/response logging
- OpenTelemetry tracing

**Usage** (`Program.cs`):

```csharp
using Acmecorp.AspNetCore;

var builder = WebApplication.CreateBuilder(args);

// Corporate starter automatically configures:
// - Serilog
// - Authentication
// - Authorization
// - Health checks
// - OpenTelemetry
builder.AddAcmecorpServices();

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Corporate middleware pipeline
app.UseAcmecorpMiddleware();

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.MapHealthChecks("/health");

app.Run();
```

### Security & Authentication

**MUST USE**: Corporate security library for JWT authentication

**Package**:

```bash
dotnet add package Acmecorp.Security.AspNetCore
```

**Configuration** (`appsettings.json`):

```json
{
  "Acmecorp": {
    "Security": {
      "Jwt": {
        "Authority": "https://auth.acmecorp.com",
        "Audience": "acmecorp-services",
        "RequireHttpsMetadata": true
      },
      "Cors": {
        "AllowedOrigins": [
          "https://app.acmecorp.com"
        ]
      }
    }
  }
}
```

**Usage**:

```csharp
using Acmecorp.Security;
using Microsoft.AspNetCore.Authorization;

[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet]
    [Authorize(Roles = "User,Admin")]
    public async Task<ActionResult<List<UserDto>>> GetUsers()
    {
        // Corporate security automatically validates JWT
        // User claims available via HttpContext.User
        var currentUserId = User.GetAcmecorpUserId();
        return Ok(await _userService.GetUsersAsync(currentUserId));
    }

    [HttpPost]
    [Authorize(Roles = "Admin")]
    [AuditLog(Action = "CREATE_USER")]  // Corporate audit logging
    public async Task<ActionResult<UserDto>> CreateUser([FromBody] CreateUserRequest request)
    {
        return Ok(await _userService.CreateUserAsync(request));
    }
}
```

### API Client

**MUST USE**: Corporate HTTP client for inter-service communication

**Package**:

```bash
dotnet add package Acmecorp.Http.Client
```

**Usage**:

```csharp
using Acmecorp.Http.Client;

// Startup configuration
builder.Services.AddAcmecorpHttpClient<IOrderServiceClient, OrderServiceClient>(options =>
{
    options.BaseAddress = new Uri(builder.Configuration["Services:OrderService:Url"]);
    options.EnableCircuitBreaker = true;
    options.EnableRetry = true;
    options.RetryCount = 3;
});

// Client interface
public interface IOrderServiceClient
{
    Task<List<OrderDto>> GetOrdersByUserIdAsync(string userId);
    Task<OrderDto> CreateOrderAsync(CreateOrderRequest request);
}

// Client implementation
public class OrderServiceClient : IOrderServiceClient
{
    private readonly HttpClient _httpClient;

    public OrderServiceClient(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }

    public async Task<List<OrderDto>> GetOrdersByUserIdAsync(string userId)
    {
        // Corporate client automatically adds:
        // - Authorization header (JWT propagation)
        // - Correlation ID
        // - Circuit breaker
        // - Retry with exponential backoff
        var response = await _httpClient.GetAsync($"/api/orders?userId={userId}");
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadFromJsonAsync<List<OrderDto>>();
    }
}

// Usage in service
public class UserService
{
    private readonly IOrderServiceClient _orderClient;

    public UserService(IOrderServiceClient orderClient)
    {
        _orderClient = orderClient;
    }

    public async Task<UserWithOrdersDto> GetUserWithOrdersAsync(string userId)
    {
        var orders = await _orderClient.GetOrdersByUserIdAsync(userId);
        // ...
    }
}
```

### Database Access

**MUST USE**: Entity Framework Core with corporate conventions

**Packages**:

```bash
dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
# Or: Microsoft.EntityFrameworkCore.PostgreSQL
dotnet add package Microsoft.EntityFrameworkCore.Tools
dotnet add package Acmecorp.EntityFrameworkCore.Extensions
```

**Entity example**:

```csharp
using Acmecorp.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;

public class User : AuditedEntity  // Corporate base entity
{
    public int Id { get; set; }

    [Required]
    [MaxLength(255)]
    public string Email { get; set; }

    [Required]
    public string PasswordHash { get; set; }

    public UserStatus Status { get; set; }

    // Audit properties inherited from AuditedEntity:
    // - CreatedAt
    // - CreatedBy
    // - UpdatedAt
    // - UpdatedBy
    // - Version (for optimistic concurrency)

    public ICollection<Order> Orders { get; set; }
}

public enum UserStatus
{
    Active,
    Inactive,
    Suspended
}
```

**DbContext**:

```csharp
using Microsoft.EntityFrameworkCore;
using Acmecorp.EntityFrameworkCore;

public class ApplicationDbContext : AcmecorpDbContext  // Corporate base DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    public DbSet<User> Users { get; set; }
    public DbSet<Order> Orders { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);  // Applies corporate configurations

        modelBuilder.Entity<User>(entity =>
        {
            entity.HasIndex(e => e.Email).IsUnique();
            entity.HasIndex(e => e.Status);
        });
    }
}
```

**Registration** (`Program.cs`):

```csharp
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));
```

### Database Migration

**MUST USE**: EF Core Migrations

**Create migration**:

```bash
dotnet ef migrations add InitialCreate --project src/UserService.Infrastructure
```

**Apply migration**:

```bash
dotnet ef database update --project src/UserService.Infrastructure
```

**Migration example**:

```csharp
public partial class InitialCreate : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "Users",
            columns: table => new
            {
                Id = table.Column<int>(nullable: false)
                    .Annotation("SqlServer:Identity", "1, 1"),
                Email = table.Column<string>(maxLength: 255, nullable: false),
                PasswordHash = table.Column<string>(nullable: false),
                Status = table.Column<int>(nullable: false),
                CreatedAt = table.Column<DateTime>(nullable: false),
                CreatedBy = table.Column<string>(maxLength: 255, nullable: true),
                UpdatedAt = table.Column<DateTime>(nullable: false),
                UpdatedBy = table.Column<string>(maxLength: 255, nullable: true),
                Version = table.Column<byte[]>(rowVersion: true, nullable: true)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_Users", x => x.Id);
            });

        migrationBuilder.CreateIndex(
            name: "IX_Users_Email",
            table: "Users",
            column: "Email",
            unique: true);
    }
}
```

### Logging (Mandatory)

**MUST USE**: Serilog with structured JSON logging

**Already included** in corporate ASP.NET Core starter.

**Additional packages** (if needed):

```bash
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Sinks.Console
dotnet add package Serilog.Sinks.File
```

**Configuration** (`Program.cs`):

```csharp
using Serilog;

Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .CreateLogger();

builder.Host.UseSerilog();
```

**Usage**:

```csharp
using Microsoft.Extensions.Logging;

public class UserService
{
    private readonly ILogger<UserService> _logger;
    private readonly ApplicationDbContext _context;

    public UserService(ILogger<UserService> logger, ApplicationDbContext context)
    {
        _logger = logger;
        _context = context;
    }

    public async Task<UserDto> CreateUserAsync(CreateUserRequest request)
    {
        _logger.LogInformation("Creating user with email: {Email}", request.Email);

        try
        {
            var user = new User
            {
                Email = request.Email,
                PasswordHash = HashPassword(request.Password),
                Status = UserStatus.Active
            };

            _context.Users.Add(user);
            await _context.SaveChangesAsync();

            _logger.LogInformation("User created successfully with ID: {UserId}", user.Id);
            return MapToDto(user);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create user with email: {Email}", request.Email);
            throw;
        }
    }
}
```

### Validation

**MUST USE**: FluentValidation

**Package**:

```bash
dotnet add package FluentValidation
dotnet add package FluentValidation.AspNetCore
```

**Validator**:

```csharp
using FluentValidation;

public class CreateUserRequestValidator : AbstractValidator<CreateUserRequest>
{
    public CreateUserRequestValidator()
    {
        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email is required")
            .EmailAddress().WithMessage("Email must be valid")
            .Must(BeAcmecorpEmail).WithMessage("Must use corporate email domain");

        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("Password is required")
            .MinimumLength(12).WithMessage("Password must be at least 12 characters")
            .Matches(@"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&]).*$")
            .WithMessage("Password must contain uppercase, lowercase, digit, and special character");

        RuleFor(x => x.FirstName)
            .NotEmpty().WithMessage("First name is required")
            .MaximumLength(100);

        RuleFor(x => x.LastName)
            .NotEmpty().WithMessage("Last name is required")
            .MaximumLength(100);
    }

    private bool BeAcmecorpEmail(string email)
    {
        return email?.EndsWith("@acmecorp.com") == true;
    }
}
```

**Registration** (`Program.cs`):

```csharp
using FluentValidation;

builder.Services.AddValidatorsFromAssemblyContaining<CreateUserRequestValidator>();
```

**Usage in controller**:

```csharp
[HttpPost]
public async Task<ActionResult<UserDto>> CreateUser([FromBody] CreateUserRequest request)
{
    var validator = new CreateUserRequestValidator();
    var validationResult = await validator.ValidateAsync(request);

    if (!validationResult.IsValid)
    {
        return BadRequest(validationResult.Errors);
    }

    return Ok(await _userService.CreateUserAsync(request));
}
```

### Testing

**MUST USE**: xUnit + Moq + FluentAssertions

**Packages**:

```bash
dotnet add package xunit
dotnet add package xunit.runner.visualstudio
dotnet add package Moq
dotnet add package FluentAssertions
dotnet add package Microsoft.AspNetCore.Mvc.Testing
dotnet add package Acmecorp.Testing.Utilities
```

**Unit test example**:

```csharp
using Xunit;
using Moq;
using FluentAssertions;

public class UserServiceTests
{
    private readonly Mock<ApplicationDbContext> _mockContext;
    private readonly Mock<ILogger<UserService>> _mockLogger;
    private readonly UserService _sut;

    public UserServiceTests()
    {
        _mockContext = new Mock<ApplicationDbContext>();
        _mockLogger = new Mock<ILogger<UserService>>();
        _sut = new UserService(_mockLogger.Object, _mockContext.Object);
    }

    [Fact]
    public async Task CreateUserAsync_WithValidRequest_ShouldReturnUserDto()
    {
        // Arrange
        var request = new CreateUserRequest
        {
            Email = "user@example.com",
            Password = "SecurePassword123!",
            FirstName = "John",
            LastName = "Doe"
        };

        // Act
        var result = await _sut.CreateUserAsync(request);

        // Assert
        result.Should().NotBeNull();
        result.Email.Should().Be("user@example.com");
        _mockContext.Verify(x => x.SaveChangesAsync(default), Times.Once);
    }
}
```

**Integration test example**:

```csharp
using Microsoft.AspNetCore.Mvc.Testing;
using System.Net.Http.Json;

public class UsersControllerIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;

    public UsersControllerIntegrationTests(WebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task CreateUser_WithValidData_ShouldReturn201()
    {
        // Arrange
        var request = new CreateUserRequest
        {
            Email = "user@example.com",
            Password = "SecurePassword123!",
            FirstName = "John",
            LastName = "Doe"
        };

        // Act
        var response = await _client.PostAsJsonAsync("/api/users", request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.Created);
        var user = await response.Content.ReadFromJsonAsync<UserDto>();
        user.Email.Should().Be("user@example.com");
    }
}
```

## 4. Banned Libraries

**DO NOT USE** the following. Use corporate alternatives instead:

### HTTP Clients

❌ **BANNED**:

- RestSharp (use corporate HTTP client)
- Direct HttpClient usage without corporate wrapper

✅ **USE INSTEAD**: `Acmecorp.Http.Client`

### Logging (Banned)

❌ **BANNED**:

- log4net
- NLog (unless approved)
- Console.WriteLine for logging

✅ **USE**: Serilog (included in corporate starter)

### JSON Serialization

❌ **RESTRICTED**:

- Newtonsoft.Json (prefer System.Text.Json)

✅ **PREFER**: System.Text.Json (built-in)

## 5. Architecture Patterns

### Clean Architecture / Onion Architecture

**MUST** follow layered architecture:

```text
API → Application → Domain ← Infrastructure
```

- **API**: Controllers, middleware, filters
- **Application**: Services, DTOs, interfaces, validators
- **Domain**: Entities, enums, value objects, domain logic
- **Infrastructure**: DbContext, repositories, external service clients

### DTOs vs Entities

**MUST** separate DTOs from entities:

```csharp
// Entity (Domain)
public class User
{
    public int Id { get; set; }
    public string Email { get; set; }
    public string PasswordHash { get; set; }  // Never expose
}

// DTO (Application)
public record UserDto(
    int Id,
    string Email,
    string FirstName,
    string LastName,
    DateTime CreatedAt
);

// Request DTO
public record CreateUserRequest(
    string Email,
    string Password,
    string FirstName,
    string LastName
);
```

### Exception Handling

**MUST** use centralized exception handling:

```csharp
using Microsoft.AspNetCore.Diagnostics;

app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async context =>
    {
        var exceptionHandler = context.Features.Get<IExceptionHandlerFeature>();
        var exception = exceptionHandler?.Error;

        var errorResponse = exception switch
        {
            NotFoundException => new { Code = "NOT_FOUND", Message = exception.Message },
            ValidationException => new { Code = "VALIDATION_ERROR", Message = exception.Message },
            _ => new { Code = "INTERNAL_ERROR", Message = "An error occurred" }
        };

        context.Response.StatusCode = exception switch
        {
            NotFoundException => StatusCodes.Status404NotFound,
            ValidationException => StatusCodes.Status400BadRequest,
            _ => StatusCodes.Status500InternalServerError
        };

        context.Response.ContentType = "application/json";
        await context.Response.WriteAsJsonAsync(errorResponse);
    });
});
```

## 6. Security & Compliance

### Input Validation

**ALWAYS** validate all inputs using FluentValidation.

### SQL Injection Prevention

**ALWAYS** use parameterized queries (EF Core handles this automatically).

### Secrets Management

**NEVER** hardcode secrets:

```csharp
// ❌ NEVER
private const string ApiKey = "sk-12345-abcdef";

// ✅ DO THIS
private readonly string _apiKey = configuration["Acmecorp:ApiKey"];
```

**Use** Azure Key Vault or corporate secrets manager:

```json
{
  "Acmecorp": {
    "KeyVault": {
      "Url": "https://acmecorp-kv.vault.azure.net/"
    }
  }
}
```

## 7. Coding Standards

### .NET Version

**MUST** use .NET 6 or later (LTS):

```xml
<PropertyGroup>
  <TargetFramework>net8.0</TargetFramework>
</PropertyGroup>
```

### C# Version

**USE** latest C# features:

- Records for DTOs
- Pattern matching
- Nullable reference types

### Naming Conventions

- **Classes**: PascalCase (`UserService`, `UsersController`)
- **Methods**: PascalCase (`CreateUserAsync`, `GetByIdAsync`)
- **Properties**: PascalCase (`Email`, `CreatedAt`)
- **Private fields**: camelCase with underscore (`_logger`, `_context`)
- **Constants**: PascalCase (`MaxRetries`, `ApiVersion`)

### Async/Await

**ALWAYS** use async/await for I/O operations:

```csharp
// ✅ Good
public async Task<UserDto> GetUserAsync(int id)
{
    var user = await _context.Users.FindAsync(id);
    return MapToDto(user);
}

// ❌ Bad - blocking
public UserDto GetUser(int id)
{
    var user = _context.Users.Find(id);
    return MapToDto(user);
}
```

## 8. Build & Deployment

### Build

```bash
dotnet build
dotnet publish -c Release -o ./publish
```

### Docker

**Dockerfile**:

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ["src/UserService.Api/UserService.Api.csproj", "src/UserService.Api/"]
RUN dotnet restore "src/UserService.Api/UserService.Api.csproj"
COPY . .
RUN dotnet publish "src/UserService.Api/UserService.Api.csproj" -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /app/publish .
EXPOSE 80
ENTRYPOINT ["dotnet", "UserService.Api.dll"]
```

## 9. Performance

**MUST**:

- Use async/await for I/O operations
- Implement caching (IMemoryCache, IDistributedCache)
- Use pagination for large result sets
- Optimize EF Core queries (use AsNoTracking for read-only)

## 10. Observability

**MUST** include:

- Health checks (`/health`)
- Metrics (Prometheus)
- Distributed tracing (OpenTelemetry)
- Structured logging (Serilog)

**Included** in corporate ASP.NET Core starter.

## See Also

- `README.md` - Guidelines overview
- `branching-guidelines.md` - Branch naming conventions
- Internal developer portal for corporate library documentation
