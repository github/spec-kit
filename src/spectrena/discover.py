"""
Spectrena Discovery Module

Phase -2: Pre-architecture exploration before init.

Helps users understand their problem domain, identify component boundaries,
and make informed architectural decisions before committing to a spec structure.

Usage:
    spectrena discover "Build a productivity system for ADHD users"
    spectrena discover --from-file prd.md
"""

from pathlib import Path
from typing import Any, Annotated
from datetime import datetime
import os

import httpx
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Confirm
from rich.progress import Progress, SpinnerColumn, TextColumn

import typer

console = Console()

# API Configuration
ANTHROPIC_API_URL = "https://api.anthropic.com/v1/messages"
DEFAULT_MODEL = "claude-opus-4-5-20251101"
MAX_TOKENS = 8192  # Opus can handle longer, more detailed analysis

# =============================================================================
# DISCOVERY PROMPT TEMPLATE
# =============================================================================

DISCOVERY_PROMPT = """
You are an expert software architect helping a developer understand their problem domain before they begin structured specification work.

## Your Task

Analyze the following project description and produce a comprehensive discovery document that will inform architecture and specification decisions.

## Project Description

{description}

## Additional Context (if provided)

{context}

## Output Format

Produce a markdown document with the following sections:

### 1. Problem Space Analysis

- What core problem is being solved?
- Who are the primary users/personas?
- What are the key user journeys?
- What pain points does this address?

### 2. Domain Analysis

- What are the major domain concepts/entities?
- What are the key business rules?
- Are there existing solutions? How is this different?
- What domain expertise is required?

### 3. Suggested Architecture

Based on the problem complexity, recommend ONE of:

**Monolithic (Simple)**
- Single deployment unit
- Spec format: `{{NNN}}-{{slug}}`
- Best for: Small projects, MVPs, single-developer teams

**Component-Based (Modular)**
- Logical separation within one codebase
- Spec format: `{{component}}-{{NNN}}-{{slug}}`
- Best for: Medium projects, clear domain boundaries, team collaboration
- Suggested components: [LIST 3-6 COMPONENTS WITH RATIONALE]

**Service-Oriented (Distributed)**
- Multiple deployment units
- Spec format: `{{project}}-{{component}}-{{NNN}}-{{slug}}`
- Best for: Large projects, multiple teams, independent scaling needs
- Suggested services: [LIST SERVICES WITH BOUNDARIES]

Provide clear rationale for your recommendation.

### 4. Suggested Components/Modules

If recommending Component-Based or Service-Oriented:

| Component | Responsibility | Key Entities | Dependencies |
|-----------|---------------|--------------|--------------|
| [NAME] | [What it owns] | [Main data] | [What it needs] |

### 5. Technical Considerations

- What technical constraints are apparent?
- What integrations might be needed?
- What are the likely technology choices?
- What are the scalability considerations?

### 6. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| [Risk] | H/M/L | H/M/L | [How to address] |

### 7. Open Questions

List 5-10 questions that should be answered during the constitution and specification phases:

1. [Question about scope/boundaries]
2. [Question about users/permissions]
3. [Question about data/persistence]
...

### 8. Recommended Next Steps

1. [Immediate next action]
2. [Following action]
3. [Action before /spectrena]

---

## For Constitution Phase

Suggested non-negotiables to consider:
- [Principle 1]
- [Principle 2]
- [Principle 3]
"""

# =============================================================================
# DISCOVERY OUTPUT TEMPLATE
# =============================================================================

DISCOVERY_TEMPLATE = """# Discovery: {project_name}

**Generated**: {timestamp}
**Status**: DRAFT - Review and refine before proceeding

---

{ai_analysis}

---

## Spectrena Configuration Recommendation

Based on this analysis, the recommended configuration is:

```yaml
spec_id:
  template: "{recommended_template}"
  padding: 3
{components_yaml}  numbering_source: "directory"
```

## Next Steps

1. Review this discovery document
2. Refine the component list if needed
3. Run: `spectrena init {project_slug} --ai claude --from-discovery`
4. Define your project constitution (non-negotiables)

---

*This document was generated by `spectrena discover`. Edit freely before proceeding.*
"""

# =============================================================================
# DISCOVERY COMMAND
# =============================================================================


def run_discovery(
    description: str,
    context_file: Path | None = None,
    output_dir: Path | None = None,
    model: str = "claude",
) -> Path | None:
    """
    Run the discovery phase to analyze a project before init.

    Args:
        description: Natural language project description
        context_file: Optional file with additional context (PRD, notes, etc.)
        output_dir: Where to write discovery.md (default: .spectrena/)
        model: AI model to use for analysis

    Returns:
        Path to generated discovery.md
    """
    console.print("\n")
    console.rule("[bold cyan]Spectrena Discovery[/bold cyan]")
    console.print()

    # Load additional context if provided
    context = ""
    if context_file and context_file.exists():
        context = context_file.read_text()
        console.print(
            f"[green]✓[/green] Loaded context from [cyan]{context_file}[/cyan]"
        )

    # Show what we're analyzing
    console.print(
        Panel(
            description,
            title="[bold]Project Description[/bold]",
            border_style="cyan",
        )
    )

    # Confirm before proceeding (AI call)
    console.print()
    if not Confirm.ask("Proceed with discovery analysis?", default=True):
        console.print("[yellow]Discovery cancelled[/yellow]")
        return None

    # Run AI analysis
    console.print()
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        task = progress.add_task("Analyzing problem domain...", total=None)

        # Build prompt
        prompt = DISCOVERY_PROMPT.format(
            description=description,
            context=context if context else "None provided",
        )

        # Call AI model
        ai_analysis = _call_ai_model(prompt, model, description)

        progress.update(task, description="Analysis complete")

    # Parse AI response to extract recommendations
    recommended_template, components = _extract_recommendations(ai_analysis)

    # Generate components YAML if applicable
    components_yaml = ""
    if components:
        components_yaml = "  components:\n"
        for comp in components:
            components_yaml += f"    - {comp}\n"

    # Generate project slug from description
    project_slug = _slugify(description.split()[0:3])

    # Build final document
    discovery_doc = DISCOVERY_TEMPLATE.format(
        project_name=description[:50] + "..." if len(description) > 50 else description,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M"),
        ai_analysis=ai_analysis,
        recommended_template=recommended_template,
        components_yaml=components_yaml,
        project_slug=project_slug,
    )

    # Determine output path
    if output_dir is None:
        output_dir = Path.cwd() / ".spectrena"
    output_dir.mkdir(parents=True, exist_ok=True)

    discovery_path = output_dir / "discovery.md"
    _ = discovery_path.write_text(discovery_doc)

    # Show summary
    console.print()
    console.rule("[bold green]Discovery Complete[/bold green]")
    console.print()

    console.print(f"[green]✓[/green] Created [cyan]{discovery_path}[/cyan]")
    console.print()

    # Show recommended architecture
    if components:
        console.print("[bold]Recommended Architecture:[/bold] Component-Based")
        console.print(f"[bold]Suggested Components:[/bold] {', '.join(components)}")
    else:
        console.print("[bold]Recommended Architecture:[/bold] Simple/Monolithic")

    console.print()
    console.print("[bold]Next Steps:[/bold]")
    console.print(f"  1. Review [cyan]{discovery_path}[/cyan]")
    console.print(
        f"  2. Run: [cyan]spectrena init {project_slug} --ai claude --from-discovery[/cyan]"
    )

    return discovery_path


def _slugify(words: list[str]) -> str:
    """Convert words to a slug."""
    return "-".join(w.lower() for w in words if w.isalnum())[:30]


def _generate_placeholder_analysis(description: str) -> str:
    """
    Generate placeholder analysis structure.

    In production, this calls the AI model. For now, returns a template
    showing what the output structure looks like.
    """
    # This is a placeholder - in production, call Claude API
    return f"""
### 1. Problem Space Analysis

*AI analysis of the problem space would appear here based on:*
> {description}

- Core problem being solved
- Primary users and personas
- Key user journeys
- Pain points addressed

### 2. Domain Analysis

- Major domain concepts identified
- Key business rules
- Competitive landscape
- Required domain expertise

### 3. Suggested Architecture

**Recommendation: Component-Based (Modular)**

Based on the description, this project appears to have clear domain boundaries
that would benefit from logical separation while maintaining a single codebase.

Rationale:
- Multiple distinct functional areas identified
- Single team/developer manageable
- Shared data layer appropriate
- Independent evolution of components valuable

### 4. Suggested Components/Modules

| Component | Responsibility | Key Entities | Dependencies |
|-----------|---------------|--------------|--------------|
| CORE | Shared utilities, config, common types | Settings, User | None |
| [DOMAIN_A] | [Primary function] | [Entities] | CORE |
| [DOMAIN_B] | [Secondary function] | [Entities] | CORE |
| [DOMAIN_C] | [Tertiary function] | [Entities] | CORE, [DOMAIN_A] |

### 5. Technical Considerations

- Consider local-first architecture for offline capability
- State management approach needs decision
- Data sync strategy if multi-device
- API design for potential future expansion

### 6. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Scope creep | High | High | Strict phase boundaries in specs |
| Over-engineering | Medium | Medium | Start simple, evolve based on need |
| Integration complexity | Low | Medium | Define clear component interfaces |

### 7. Open Questions

1. What is the primary platform (mobile, desktop, web)?
2. Is offline functionality required?
3. What is the data persistence strategy?
4. Are there existing systems to integrate with?
5. What is the expected user scale?
6. Are there compliance/privacy requirements?
7. What is the timeline for initial release?

### 8. Recommended Next Steps

1. Answer the open questions above
2. Validate component boundaries with a simple diagram
3. Define non-negotiables for constitution
4. Start with CORE component specification
"""


def _call_ai_model(prompt: str, model: str = "claude", description: str = "") -> str:
    """
    Call the AI model to generate discovery analysis.

    Args:
        prompt: The formatted discovery prompt
        model: Model identifier ("claude", "openai", etc.)
        description: Original description (for fallback placeholder)

    Returns:
        AI-generated analysis text

    Falls back to placeholder if API key not set or on error.
    """
    api_key = os.environ.get("ANTHROPIC_API_KEY")

    if not api_key:
        console.print(
            "[yellow]⚠ ANTHROPIC_API_KEY not set - using placeholder analysis[/yellow]"
        )
        console.print(
            "[dim]Set ANTHROPIC_API_KEY environment variable for AI-powered discovery[/dim]"
        )
        return _generate_placeholder_analysis(description)

    if model.lower() not in ("claude", "anthropic", "opus"):
        console.print(
            f"[yellow]⚠ Model '{model}' not supported yet - using Claude Opus[/yellow]"
        )

    try:
        with httpx.Client(timeout=120.0) as client:
            response = client.post(
                ANTHROPIC_API_URL,
                headers={
                    "Content-Type": "application/json",
                    "x-api-key": api_key,
                    "anthropic-version": "2023-06-01",
                },
                json={
                    "model": DEFAULT_MODEL,
                    "max_tokens": MAX_TOKENS,
                    "messages": [
                        {
                            "role": "user",
                            "content": prompt,
                        }
                    ],
                },
            )

            if response.status_code != 200:
                error_detail = response.text[:200] if response.text else "No details"
                console.print(
                    f"[red]✗ API error ({response.status_code}): {error_detail}[/red]"
                )
                console.print("[yellow]Falling back to placeholder analysis[/yellow]")
                return _generate_placeholder_analysis(description)

            data: dict[str, Any] = response.json()

            # Extract text from response
            if "content" in data and len(data["content"]) > 0:
                return str(data["content"][0].get("text", ""))
            else:
                console.print("[red]✗ Unexpected API response format[/red]")
                return _generate_placeholder_analysis(description)

    except httpx.TimeoutException:
        console.print("[red]✗ API request timed out[/red]")
        console.print("[yellow]Falling back to placeholder analysis[/yellow]")
        return _generate_placeholder_analysis(description)
    except httpx.RequestError as e:
        console.print(f"[red]✗ API request failed: {e}[/red]")
        console.print("[yellow]Falling back to placeholder analysis[/yellow]")
        return _generate_placeholder_analysis(description)
    except Exception as e:
        console.print(f"[red]✗ Unexpected error: {e}[/red]")
        console.print("[yellow]Falling back to placeholder analysis[/yellow]")
        return _generate_placeholder_analysis(description)


def _extract_recommendations(analysis: str) -> tuple[str, list[str]]:
    """
    Extract template recommendation and components from AI analysis.

    Returns:
        Tuple of (template_string, list_of_components)
    """
    # Simple heuristic extraction - in production, ask AI to output structured data

    components = []
    template = "{NNN}-{slug}"

    # Look for component-based recommendation
    if "component-based" in analysis.lower() or "modular" in analysis.lower():
        template = "{component}-{NNN}-{slug}"

        # Try to extract component names from table
        import re

        # Match table rows like "| CORE | ..." or "| [DOMAIN_A] | ..."
        matches = re.findall(r"\|\s*([A-Z][A-Z0-9_]*)\s*\|", analysis)
        if matches:
            # Filter out header-like matches
            components = [m for m in matches if m not in ("Component", "NAME", "Risk")]

    elif "service-oriented" in analysis.lower() or "distributed" in analysis.lower():
        template = "{project}-{component}-{NNN}-{slug}"
        # Similar extraction logic

    return template, components


# =============================================================================
# CLI COMMAND DEFINITION
# =============================================================================


def add_discover_command(app: typer.Typer) -> None:
    """
    Add the discover command to a Typer app.

    Usage in __init__.py:
        from .spectrena_discover import add_discover_command
        add_discover_command(app)
    """

    @app.command()
    def discover(
        description: Annotated[
            str,
            typer.Argument(
                help="Natural language description of what you want to build"
            ),
        ],
        context_file: Annotated[
            Path | None,
            typer.Option(
                "--context",
                "-c",
                help="File with additional context (PRD, notes, etc.)",
                exists=True,
            ),
        ] = None,
        output_dir: Annotated[
            Path | None,
            typer.Option(
                "--output",
                "-o",
                help="Output directory for discovery.md",
            ),
        ] = None,
    ) -> None:
        """
        Explore a project idea before committing to architecture.

        Phase -2 of the Spectrena workflow. Analyzes your project description
        and recommends architecture, components, and configuration.

        Examples:

            spectrena discover "Build a task management app for ADHD users"

            spectrena discover "Enterprise reporting system" --context prd.md

            spectrena discover "Mobile fitness tracker" -o ./docs
        """
        _ = run_discovery(
            description=description,
            context_file=context_file,
            output_dir=output_dir,
        )


# =============================================================================
# INIT INTEGRATION: --from-discovery FLAG
# =============================================================================


def load_discovery_recommendations(
    discovery_path: Path | None = None,
) -> dict[str, Any]:
    """
    Load recommendations from discovery.md to pre-populate init config.

    Args:
        discovery_path: Path to discovery.md (default: .spectrena/discovery.md)

    Returns:
        Dict with spec_id config recommendations
    """
    if discovery_path is None:
        discovery_path = Path.cwd() / ".spectrena" / "discovery.md"

    if not discovery_path.exists():
        console.print(
            f"[yellow]Warning: Discovery file not found at {discovery_path}[/yellow]"
        )
        return {}

    content = discovery_path.read_text()

    # Extract YAML config block
    import re

    yaml_match = re.search(r"```yaml\s*\nspec_id:(.*?)```", content, re.DOTALL)

    if not yaml_match:
        return {}

    yaml_block = yaml_match.group(1)

    # Simple parsing (not full YAML parser to avoid dependency)
    config = {}

    template_match = re.search(r'template:\s*["\']?([^"\']+)["\']?', yaml_block)
    if template_match:
        config["template"] = template_match.group(1).strip()

    components_match = re.findall(r"-\s*(\w+)", yaml_block)
    if components_match:
        config["components"] = components_match

    return config


# =============================================================================
# STANDALONE TEST
# =============================================================================

if __name__ == "__main__":
    console.print("[bold]Spectrena Discovery Test[/bold]\n")

    test_description = """
    Build a productivity ecosystem for ADHD users consisting of three apps:
    1. A guidance app for task capture and planning
    2. A knowledge management app for notes and references  
    3. A tracking app for habits and time
    All apps should work offline-first and sync when connected.
    """

    _ = run_discovery(test_description.strip())
